#include "framework.h"
#include "aura/os/windows/windows_system_interaction_impl.h"
#include "aura/.h"


//const GUID CLSID_TaskbarList = { 0x56FDF344, 0xFD6D, 0x11D0,{ 0x95, 0x8A, 0x00, 0x60, 0x97, 0xC9, 0xA0, 0x90 } };
//const GUID IID_ITaskbarList = { 0x56FDF342, 0xFD6D, 0x11D0,{ 0x95, 0x8A, 0x00, 0x60, 0x97, 0xC9, 0xA0, 0x90 } };
//const GUID IID_ITaskbarList2 = { 0x602D4995, 0xB13A, 0x429b,{ 0xA6, 0x6E, 0x19, 0x35, 0xE4, 0x4F, 0x43, 0x17 } };
//const GUID IID_ITaskList3 = { 0xEA1AFB91, 0x9E28, 0x4B86,{ 0x90, 0xE9, 0x9E, 0x9F, 0x8A, 0x5E, 0xEF, 0xAF } };

CLASS_DECL_AURA int g_iMouseDown = 0;

CLASS_DECL_AURA thread_int_ptr < DWORD_PTR > t_time1;
CLASS_DECL_AURA thread_int_ptr < DWORD_PTR > t_time2;


extern CLASS_DECL_AURA thread_int_ptr < DWORD_PTR > t_time1;

thread_int_ptr < HHOOK > t_hHookOldCbtFilter;
thread_pointer < ::windows::interaction_impl  > t_pwndInit;

//LRESULT CALLBACK __activation_window_procedure(oswindow oswindow,UINT nMsg,WPARAM wParam,LPARAM lParam);

const char * gen_OldWndProc = "::aura::OldWndProc423";

CLASS_DECL_AURA bool hook_window_create(::windows::interaction_impl * pwindow);


#define __WNDCLASS(s)    L"ca2" L##s
#define __WND             __WNDCLASS("Wnd")
#define __WNDCONTROLBAR   __WNDCLASS("ControlBar")
#define __WNDMDIFRAME     __WNDCLASS("MDIFrame")
#define __WNDFRAMEORVIEW  __WNDCLASS("FrameOrView")
#define __WNDOLECONTROL   __WNDCLASS("OleControl")


const unichar gen_WndControlBar[] = __WNDCONTROLBAR;
const unichar gen_WndMDIFrame[] = __WNDMDIFRAME;
const unichar gen_WndFrameOrView[] = __WNDFRAMEORVIEW;
const unichar gen_WndOleControl[] = __WNDOLECONTROL;

struct __CTLCOLOR
{
   oswindow oswindow;
   HDC hDC;
   UINT nCtlType;
};


const unichar gen_Wnd[] = __WND;


namespace windows
{


   interaction_impl::interaction_impl()
   {

      user_common_construct();

   }


   HRESULT STDMETHODCALLTYPE interaction_impl::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL point, DWORD *pdwEffect)
   {

      ::message::drag_and_drop m(this, MESSAGE_OLE_DRAGENTER);

      m.pDataObj = pDataObj;
      m.grfKeyState = grfKeyState;
      m.point = point;
      m.dwEffect = DROPEFFECT_NONE;

      try
      {

         message_handler(&m);

      }
      catch (...)
      {

      }

      // Call the drag and drop helper.
      if (m_bUseDnDHelper)
      {
         // The DnD helper needs an IDataObject interface, so get one from
         // the COleDataObject.  Note that the FALSE lparam means that
         // GetIDataObject will not AddRef() the returned interface, so
         // we do not Release() it.
         ::point point(m.point.x, m.point.y);

         m_piDropHelper->DragEnter(get_handle(), m.pDataObj, &point, m.dwEffect);
      }

      *pdwEffect = m.dwEffect;

      return S_OK;

   }


   HRESULT STDMETHODCALLTYPE interaction_impl::DragOver(DWORD grfKeyState, POINTL point,  DWORD *pdwEffect)
   {

      ::message::drag_and_drop m(this, MESSAGE_OLE_DRAGOVER);

      m.pDataObj = nullptr;
      m.grfKeyState = grfKeyState;
      m.point = point;
      m.dwEffect = DROPEFFECT_NONE;

      try
      {

         message_handler(&m);

      }
      catch (...)
      {

      }

      // Call the drag and drop helper.
      if (m_bUseDnDHelper)
      {
         // The DnD helper needs an IDataObject interface, so get one from
         // the COleDataObject.  Note that the FALSE lparam means that
         // GetIDataObject will not AddRef() the returned interface, so
         // we do not Release() it.
         ::point point(m.point.x, m.point.y);
         m_piDropHelper->DragOver(&point, m.dwEffect);
      }


      *pdwEffect = m.dwEffect;

      return S_OK;
   }


   HRESULT STDMETHODCALLTYPE interaction_impl::DragLeave(void)
   {

      ::message::drag_and_drop m(this, MESSAGE_OLE_DRAGLEAVE);

      m.pDataObj = nullptr;
      m.grfKeyState = 0;
      m.point = { 0,0 };
      m.dwEffect = DROPEFFECT_NONE;

      try
      {

         message_handler(&m);

      }
      catch (...)
      {

      }

      // Call the drag and drop helper.
      if (m_bUseDnDHelper)
      {
         m_piDropHelper->DragLeave();
      }


      return S_OK;

   }


   HRESULT STDMETHODCALLTYPE interaction_impl::Drop(IDataObject * pDataObj, DWORD grfKeyState, POINTL point, DWORD * pdwEffect)
   {

      ::message::drag_and_drop m(this, MESSAGE_OLE_DRAGDROP);

      m.pDataObj = pDataObj;
      m.grfKeyState = grfKeyState;
      m.point = point;
      m.dwEffect = DROPEFFECT_NONE;

      try
      {

         message_handler(&m);

      }
      catch (...)
      {

      }

      // Call the drag and drop helper.
      if (m_bUseDnDHelper)
      {
         // The DnD helper needs an IDataObject interface, so get one from
         // the COleDataObject.  Note that the FALSE lparam means that
         // GetIDataObject will not AddRef() the returned interface, so
         // we do not Release() it.
         ::point point(m.point.x, m.point.y);
         m_piDropHelper->Drop(m.pDataObj, &point, m.dwEffect);
      }

      *pdwEffect = m.dwEffect;

      return S_OK;

   }


   HRESULT STDMETHODCALLTYPE interaction_impl::QueryInterface(REFIID riid, void **ppvObject)
   {

      if (__uuidof(IDropTarget) == riid)
      {
         *ppvObject = this;
      }
      else if (__uuidof(IUnknown) == riid)
      {
         *ppvObject = this;
      }
      else
      {
         *ppvObject = nullptr;
         return E_FAIL;
      }

      this->AddRef();

      return S_OK;

   }


   ULONG STDMETHODCALLTYPE interaction_impl::AddRef(void)
   {

      return (ULONG)add_ref();

   }


   ULONG STDMETHODCALLTYPE interaction_impl::Release(void)
   {

      return (ULONG)release();

   }


   void interaction_impl::construct(oswindow oswindow)
   {

      set_handle(oswindow);

   }


   void interaction_impl::user_common_construct()
   {

      m_pfnSuper = nullptr;
      m_bUseDnDHelper = false;
      m_bUpdateGraphics = false;
      m_bIgnoreSizeEvent = false;
      m_bIgnoreMoveEvent = false;

      set_handle(nullptr);

      ·zero(m_size);
      ·zero(m_point);

   }


   interaction_impl::interaction_impl(::particle * pparticle) :
      ::object(pobject)
   {

      user_common_construct();

   }


   interaction_impl::~interaction_impl()
   {

   }


   void * interaction_impl::get_os_data() const
   {

      return (void *)((::windows::interaction_impl *) this)->get_handle();

   }


   __STATIC bool CLASS_DECL_AURA __modify_style(oswindow oswindow, i32 nStyleOffset,
         u32 dwRemove, u32 dwAdd, UINT nFlags)
   {
      ASSERT(oswindow != nullptr);
      u32 uStyle = ::GetWindowLong(oswindow, nStyleOffset);
      u32 dwNewStyle = (uStyle & ~dwRemove) | dwAdd;
      if (uStyle == dwNewStyle)
         return FALSE;

      ::SetWindowLong(oswindow, nStyleOffset, dwNewStyle);
      if (nFlags != 0)
      {
         ::SetWindowPos(oswindow, nullptr, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
      }
      return TRUE;
   }

   bool interaction_impl::ModifyStyle(oswindow oswindow, u32 dwRemove, u32 dwAdd, UINT nFlags)
   {

      bool bOk = __modify_style(oswindow, GWL_STYLE, dwRemove, dwAdd, 0);

      if (nFlags != 0)
      {

         //m_iShowFlags = nFlags;



      }

      return bOk;

   }


   bool interaction_impl::ModifyStyleEx(oswindow oswindow, u32 dwRemove, u32 dwAdd, UINT nFlags)
   {

      return __modify_style(oswindow, GWL_EXSTYLE, dwRemove, dwAdd, nFlags);

   }


   LRESULT interaction_impl::Default()
   {

      return DefWindowProc(m_uiMessage, m_wparam, m_lparam);

   }


   void interaction_impl::pre_subclass_window()
   {

   }





   bool interaction_impl::_native_create_window_ex(::user::create_struct & cs)
   {

      ASSERT(cs.lpszClass == nullptr || __is_valid_string(cs.lpszClass) || __is_valid_atom(cs.lpszClass));


      ENSURE_ARG(cs.lpszName == nullptr || __is_valid_string(cs.lpszName));


      string strClassName(cs.lpszClass);


      if (strClassName.is_empty())
      {

         strClassName = m_puserinteraction->calc_window_class();

      }

      cs.lpszClass = strClassName;


      install_message_routing(m_puserinteraction);

      if (!hook_window_create(this))
      {

         PostNcDestroy();

         return false;

      }

      // if window is not created, it may destroy this object, so keep the app as local var

      ::aura::application * papp = m_papp;

      wstring wstrClassName(cs.lpszClass);


      wstring wstrWindowName(cs.lpszName);


      oswindow oswindow = ::CreateWindowExW(
                          cs.dwExStyle,
                          wstrClassName,
                          wstrWindowName,
                          cs.style,
                          cs.x, cs.y, cs.cx(), cs.cy(),
                          cs.hwndParent, cs.hMenu, cs.hInstance, cs.lpCreateParams);

      ::set_thread_name(m_puserinteraction->type_name());
      u32 dwLastError = get_last_error();

      if (!unhook_window_create())
      {

         PostNcDestroy();        // cleanup if CreateWindowEx fails too soon

      }

      if (cs.hwndParent == HWND_MESSAGE)
      {

         m_puserinteraction->m_bDrawable = false;

      }

      if (oswindow == nullptr)
      {

         if (papp == nullptr)
         {

            return false;

         }

         string strLastError = FormatMessageFromSystem(dwLastError);

         string strMessage;

         strMessage.Format("%s\n\nSystem Error Code: %d", strLastError, dwLastError);

         information(trace_category_appmsg, trace_level_warning, "Warning: Window creation failed: get_last_error returned:\n");

         information(trace_category_appmsg, trace_level_warning, "%s\n", strMessage);

         try
         {

            if (dwLastError == 0x0000057e)
            {

               informationf("Cannot create a top-level child interaction_impl.");

            }
            else
            {

               informationf("%s", strMessage);

            }

         }
         catch (...)
         {

         }

      }

      if (oswindow == nullptr)
      {

         return false;

      }

      bool bUnicode = ::IsWindowUnicode(oswindow) != FALSE;

      if (bUnicode)
      {

         output_debug_string("window is unicode");

      }
      else
      {

         output_debug_string("window is ANSI");

      }

      WNDCLASSW wndcls;

      if (wstrClassName.get_length() > 0 && GetClassInfoW(System.m_hinstance, wstrClassName, &wndcls) && wndcls.hIcon != nullptr)
      {

         Application.set_icon(m_puserinteraction, øallocate(::draw2d::icon(get_app(), wndcls.hIcon)), false);

         Application.set_icon(m_puserinteraction, øallocate(::draw2d::icon(get_app(), wndcls.hIcon)), true);

      }

      if (oswindow != get_handle())
      {

         ASSERT(FALSE); // should have been set in send msg hook

      }

      /// this Windows native window "holds" reference to the
      /// wrapping object.
      m_puserinteraction->add_ref();

      return true;

   }


   bool interaction_impl::pre_create_window(::user::create_struct& cs)
   {

      return true;

   }


   bool interaction_impl::create_message_queue(::user::interaction * puserinteraction, const char * lpszName)
   {

      if (_is_window())
      {

         DestroyWindow();

      }

      ::user::create_struct cs(0, nullptr, lpszName, WS_CHILD, nullptr);

      cs.hwndParent = HWND_MESSAGE;

      if (!native_create_window_ex(puserinteraction, cs, HWND_MESSAGE))
      {

         return false;

      }

      return true;

   }


   void interaction_impl::install_message_routing(::channel * pchannel)
   {

      last_install_message_routing(pchannel);
      ::user::interaction_impl::install_message_routing(pchannel);

      MESSAGE_LINK(e_message_ncdestroy, pchannel, this, &interaction_impl::_001OnNcDestroy);
      if (!m_puserinteraction->m_bMessageWindow)
      {
         MESSAGE_LINK(e_message_paint, pchannel, this, &interaction_impl::_001OnPaint);
         MESSAGE_LINK(WM_PRINT, pchannel, this, &interaction_impl::_001OnPrint);
      }
      m_puserinteraction->install_message_routing(pchannel);
      MESSAGE_LINK(e_message_create, pchannel, this, &interaction_impl::_001OnCreate);
      if (!m_puserinteraction->m_bMessageWindow)
      {
         MESSAGE_LINK(e_message_set_cursor, pchannel, this, &interaction_impl::_001OnSetCursor);
         MESSAGE_LINK(e_message_erase_background, pchannel, this, &interaction_impl::_001OnEraseBkgnd);
         MESSAGE_LINK(e_message_nccalcsize, pchannel, this, &interaction_impl::_001OnNcCalcSize);
         MESSAGE_LINK(e_message_show_window, pchannel, this, &interaction_impl::on_message_show_window);
         MESSAGE_LINK(e_message_move, pchannel, this, &interaction_impl::_001OnMove);
         MESSAGE_LINK(e_message_size, pchannel, this, &interaction_impl::_001OnSize);
         MESSAGE_LINK(e_message_window_position_changing, pchannel, this,&interaction_impl::_001OnWindowPosChanging);
         MESSAGE_LINK(e_message_window_position_changed, pchannel, this,&interaction_impl::_001OnWindowPosChanged);
         MESSAGE_LINK(WM_GETMINMAXINFO, pchannel, this,&interaction_impl::_001OnGetMinMaxInfo);
         MESSAGE_LINK(e_message_set_focus, pchannel, this, &interaction_impl::_001OnSetFocus);
         MESSAGE_LINK(e_message_kill_focus, pchannel, this, &interaction_impl::_001OnKillFocus);

         prio_install_message_routing(pchannel);

      }

      MESSAGE_LINK(e_message_destroy, pchannel, this, &interaction_impl::_001OnDestroy);
      MESSAGE_LINK(e_message_enable, pchannel, this, &interaction_impl::_001OnEnable);

   }

   void interaction_impl::on_message_show_window(::message::message * pmessage)
   {

      SCAST_PTR(::message::show_window, pshowwindow, pmessage);

      if (pshowwindow->m_bShow)
      {

         output_debug_string("windows::interaction_impl::on_message_show_window bShow = true");

      }
      else
      {

         output_debug_string("windows::interaction_impl::on_message_show_window bShow = false");

      }


   }

   void interaction_impl::win_update_graphics()
   {

      single_lock sl(m_puserinteraction->m_pmutex, false);

      if (!sl.lock())
      {
         m_bUpdateGraphics = true;
         return;
      }

      m_bUpdateGraphics = false;

      ::rectangle_i32 rectWindow;

      m_puserinteraction->window_rectangle(rectWindow);

      m_point = rectWindow.top_left();

      if (m_size != rectWindow.size())
      {

         //if(m_image.is_null())
         //   m_image.alloc(this);

         //m_image = create_image(rectWindow.size());

         m_size = rectWindow.size();

      }




   }


   void interaction_impl::_001OnMove(::message::message* pmessage)
   {

      if (m_bDestroyImplOnly)
      {

         return;

      }

      SCAST_PTR(::message::move, pmove, pmessage);

      m_puserinteraction->move_to(pmove->m_point);

      m_puserinteraction->m_point = pmove->m_point;

      m_puserinteraction->m_bReposition = true;

      if (!(GetExStyle() & WS_EX_LAYERED))
      {

         //m_puserinteraction->on_layout(::draw2d::graphics_pointer & pgraphics);

      }

      if (m_bIgnoreSizeEvent)
      {

         pmessage->m_bRet = true;

         return;

      }

   }



   void interaction_impl::_001OnSize(::message::message * pmessage)
   {

      if (m_bDestroyImplOnly)
      {

         return;

      }

      SCAST_PTR(::message::size, psize, pmessage);

      if (m_puserinteraction->m_sizeRequest != psize.m_size)
      {

         if (m_puserinteraction->m_size == psize.m_size)
         {

            m_puserinteraction->m_sizeRequest = psize.m_size;

            m_puserinteraction->m_size = psize.m_size;

         }
         else
         {

            m_puserinteraction->set_need_layout();

            m_puserinteraction->set_need_redraw();

         }

      }
      else
      {

         m_puserinteraction->m_sizeRequest = psize.m_size;

         m_puserinteraction->m_size = psize.m_size;

      }

      //if (!(GetExStyle() & WS_EX_LAYERED))
      //{

      //   m_puserinteraction->on_layout(::draw2d::graphics_pointer & pgraphics);

      //}

      if (::IsZoomed(m_oswindow))
      {

         ::OutputDebugString("Window is Zoomed\n");

      }

      if (m_bIgnoreSizeEvent)
      {

         pmessage->m_bRet = true;

         return;

      }

   }


   void interaction_impl::_001OnEnable(::message::message * pmessage)
   {

      SCAST_PTR(::message::enable, penable, pmessage);

      if (penable != nullptr)
      {

         if (penable->get_enable())
         {

            output_debug_string("::window::interaction_impl _001OnEnable = TRUE");

         }
         else
         {

            output_debug_string("::window::interaction_impl _001OnEnable = FALSE");

         }

      }

   }


   void interaction_impl::_001OnNcCalcSize(::message::message * pmessage)
   {

      SCAST_PTR(::message::base, pbase, pmessage);

      pbase->set_lresult(0);

      pmessage->m_bRet = true;

   }


   void interaction_impl::_001OnDestroy(::message::message * pmessage)
   {

      UNREFERENCED_PARAMETER(pmessage);

      Default();

   }


   // e_message_ncdestroy is the absolute LAST message sent.
   void interaction_impl::_001OnNcDestroy(::message::message * pmessage)
   {

      // cleanup tooltip support
      //if (m_puserinteraction != nullptr)
      //{
      //   if (m_puserinteraction->m_nFlags & WF_TOOLTIPS)
      //   {
      //   }
      //}

      // call default, unsubclass, and detach from the map

      WNDPROC pfnWndProc = WNDPROC(::GetWindowLongPtr(get_handle(), GWLP_WNDPROC));

      Default();

      if (WNDPROC(::GetWindowLongPtr(get_handle(), GWLP_WNDPROC)) == pfnWndProc)
      {

         WNDPROC pfnSuper = *GetSuperWndProcAddr();

         if (pfnSuper != nullptr)
         {

            ::SetWindowLongPtr(get_handle(), GWLP_WNDPROC, reinterpret_cast<iptr>(pfnSuper));

         }

      }

      //detach();

      //ASSERT(get_handle() == nullptr);
      //m_pfnDispatchWindowProc = &interaction_impl::_start_user_message_handler;
      // call special post-cleanup routine
      PostNcDestroy();

      //::user::interaction * puserinteraction = m_puserinteraction;

      //m_puserinteraction->PostNcDestroy();


   }


   void interaction_impl::PostNcDestroy()
   {

      ::user::interaction_impl::PostNcDestroy();

   }


   void interaction_impl::on_final_release()
   {

      if (get_handle() != nullptr)
      {

         DestroyWindow();    // will call PostNcDestroy

      }
      else
      {

         PostNcDestroy();

      }

   }


   void interaction_impl::assert_valid() const
   {
      if (((::windows::interaction_impl *)this)->get_handle() == nullptr)
         return;     // null (unattached) windows are valid

      // check for special wnd??? values
      ASSERT(HWND_TOP == nullptr);       // same as desktop
      if (((::windows::interaction_impl *)this)->get_handle() == HWND_BOTTOM)
      {
      }
      else if (((::windows::interaction_impl *)this)->get_handle() == HWND_TOPMOST)
      {
      }
      else if (((::windows::interaction_impl *)this)->get_handle() == HWND_NOTOPMOST)
      {
      }
      else
      {
         // should be a normal interaction_impl
         ASSERT(::is_window(((::windows::interaction_impl *)this)->get_handle()));

      }
   }


   void interaction_impl::dump(dump_context & dumpcontext) const
   {
      object::dump(dumpcontext);

      dumpcontext << "\nm_oswindow_ = " << ((::windows::interaction_impl *)this)->get_handle();

      if (((::windows::interaction_impl *)this)->get_handle() == nullptr || ((::windows::interaction_impl *)this)->get_handle() == HWND_BOTTOM ||
            ((::windows::interaction_impl *)this)->get_handle() == HWND_TOPMOST || ((::windows::interaction_impl *)this)->get_handle() == HWND_NOTOPMOST)
      {
         // not a normal interaction_impl - nothing more to dump
         return;
      }

      if (!::is_window(((::windows::interaction_impl *)this)->get_handle()))
      {
         // not a valid interaction_impl
         dumpcontext << " (illegal oswindow)";
         return; // don't do anything more
      }

      ::window_sp pwindow = System.ui_from_handle(((::windows::interaction_impl *)this)->get_handle());
      if (pwindow.m_p != this)
         dumpcontext << " (Detached or temporary interaction_impl)";
      else
         dumpcontext << " (permanent interaction_impl)";

      // dump out interaction_impl specific statistics
      char szBuf[64];
      //if (!const_cast < interaction_impl * > (this)->send_message(WM_QUERYAFXWNDPROC, 0, 0) && pwindow == this)
      // ((::windows::interaction_impl *)this)->get_window_text(szBuf, _countof(szBuf));
      //else
      // ::DefWindowProc(((::windows::interaction_impl *)this)->get_handle(), WM_GETTEXT, _countof(szBuf), (LPARAM)&szBuf[0]);
      //dumpcontext << "\ncaption = \"" << szBuf << "\"";

      ::GetClassName(((::windows::interaction_impl *)this)->get_handle(), szBuf, _countof(szBuf));
      dumpcontext << "\nclass name = \"" << szBuf << "\"";

      ::rectangle_i32 rect;
      ((::windows::interaction_impl *) this)->m_puserinteraction->window_rectangle(&rect);
      dumpcontext << "\nrect = " << rect;
      dumpcontext << "\nparent ::window_sp = " << ((::windows::interaction_impl *)this)->GetParent();

      dumpcontext << "\nstyle = " << (uptr)::GetWindowLong(((::windows::interaction_impl *)this)->get_handle(), GWL_STYLE);
      if (::GetWindowLong(((::windows::interaction_impl *)this)->get_handle(), GWL_STYLE) & WS_CHILD)
         dumpcontext << "\nid = " << __get_dialog_control_id(((::windows::interaction_impl *)this)->get_handle());

      dumpcontext << "\n";
   }


   void interaction_impl::on_set_parent(::user::interaction * puserinteraction)
   {

   }


   bool interaction_impl::DestroyWindow()
   {

      return ::user::interaction_impl::DestroyWindow();

      //return ::DestroyWindow(get_handle()) != FALSE;

      //bool bResult = false;

      //DWORD dwCurrentThreadId = ::GetCurrentThreadId();

      //DWORD dwWindowThreadId = ::GetWindowThreadProcessId(get_handle(), nullptr);

      //if (get_handle() != nullptr)
      //{

      //   if (dwCurrentThreadId == dwWindowThreadId)
      //   {

      //      bResult = ::DestroyWindow(get_handle()) != FALSE;

      //   }
      //   else
      //   {

      //      HANDLE hevent = ::CreateEvent(nullptr, TRUE, FALSE, nullptr);

      //      ::PostMessage(get_handle(), WM_USER + 7654, (WPARAM) hevent, (LPARAM) get_handle());

      //      ::WaitForSingleObject(hevent, 5000);

      //      ::CloseHandle(hevent);

      //      bResult = TRUE;

      //   }

      //}

      //return bResult;

   }

   /////////////////////////////////////////////////////////////////////////////
   // Default interaction_impl implementation


   LRESULT interaction_impl::DefWindowProc(UINT nMsg, WPARAM wParam, lparam lParam)

   {

      if (get_handle() == nullptr)
      {

         return 0;

      }

      if (m_pfnSuper != nullptr)
      {

         return ::CallWindowProc(m_pfnSuper, get_handle(), nMsg, wParam, lParam);

      }

      WNDPROC pfnWndProc;

      if ((pfnWndProc = *GetSuperWndProcAddr()) == nullptr)
      {

         return ::DefWindowProc(get_handle(), nMsg, wParam, lParam);

      }
      else
      {

         return ::CallWindowProc(pfnWndProc, get_handle(), nMsg, wParam, lParam);

      }

   }


   WNDPROC* interaction_impl::GetSuperWndProcAddr()
   {

      // Note: it is no longer necessary to override GetSuperWndProcAddr
      //  for each control class with a different WNDCLASS.
      //  This implementation now uses instance data, such that the previous
      //  WNDPROC can be anything.

      return &m_pfnSuper;

   }


   void interaction_impl::pre_translate_message(::message::message * pmessage)
   {

      SCAST_PTR(::message::base, pbase, pmessage);

   }


   i32 interaction_impl::GetChildByIdText(i32 nID, string & rString) const
   {

      ASSERT(::is_window(((::windows::interaction_impl *)this)->get_handle()));

      rString = "";    // is_empty without deallocating

      oswindow oswindow = ::GetDlgItem(((::windows::interaction_impl *)this)->get_handle(), nID);

      if (oswindow != nullptr)
      {

         i32 nLen = ::GetWindowTextLength(oswindow);

         ::GetWindowText(oswindow, rString.GetBufferSetLength(nLen), nLen + 1);

         rString.ReleaseBuffer();

      }

      return (i32)rString.get_length();

   }


   bool interaction_impl::GetWindowPlacement(WINDOWPLACEMENT* pwndpl)

   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      pwndpl->length = sizeof(WINDOWPLACEMENT);


      return ::GetWindowPlacement(get_handle(), pwndpl) != FALSE;


   }


   bool interaction_impl::SetWindowPlacement(const WINDOWPLACEMENT* pwndpl)

   {

      sync_lock sl(m_puserinteraction->m_pmutex);

      ASSERT(::is_window(get_handle()));

      ((WINDOWPLACEMENT*)pwndpl)->length = sizeof(WINDOWPLACEMENT);


      return ::SetWindowPlacement(get_handle(), pwndpl) != FALSE;


   }


   /////////////////////////////////////////////////////////////////////////////
   // interaction_impl will delegate owner draw messages to self drawing controls

   // Drawing: for all 4 control types
   void interaction_impl::OnDrawItem(i32 /*nIDCtl*/, LPDRAWITEMSTRUCT pDrawItemStruct)

   {

      // reflect notification to child interaction_impl control
      //      if (ReflectMessage(pDrawItemStruct->hwndItem))

      //       return;     // eat it

      // not handled - do default
      Default();
   }

   // Drawing: for all 4 control types
   i32 interaction_impl::OnCompareItem(i32 /*nIDCtl*/, LPCOMPAREITEMSTRUCT pCompareItemStruct)

   {
      // reflect notification to child interaction_impl control
      //      LRESULT lResult;
      //      if (ReflectLastMsg(pCompareItemStruct->hwndItem, &lResult))

      //       return (i32)lResult;        // eat it

      // not handled - do default
      return (i32)Default();
   }

   void interaction_impl::OnDeleteItem(i32 /*nIDCtl*/, LPDELETEITEMSTRUCT pDeleteItemStruct)

   {
      // reflect notification to child interaction_impl control
      //if (ReflectLastMsg(pDeleteItemStruct->hwndItem))

      // return;     // eat it
      // not handled - do default
      Default();
   }

   bool interaction_impl::_EnableToolTips(bool bEnable, UINT nFlag)
   {
      UNREFERENCED_PARAMETER(bEnable);
      UNREFERENCED_PARAMETER(nFlag);
      return FALSE;
   }



   bool interaction_impl::GetWindowInfo(PWINDOWINFO pwi) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      return ::GetWindowInfo(((interaction_impl *)this)->get_handle(), pwi) != FALSE;
   }

   ::window_sp interaction_impl::GetAncestor(UINT gaFlags) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      return  System.ui_from_handle(::GetAncestor(((interaction_impl *)this)->get_handle(), gaFlags));
   }



   bool interaction_impl::GetScrollBarInfo(LONG idObject, PSCROLLBARINFO psbi) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      ASSERT(psbi != nullptr);
      return ::GetScrollBarInfo(((interaction_impl *)this)->get_handle(), idObject, psbi) != FALSE;
   }

   bool interaction_impl::GetTitleBarInfo(PTITLEBARINFO pti) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      ASSERT(pti != nullptr);
      return ::GetTitleBarInfo(((interaction_impl *)this)->get_handle(), pti) != FALSE;
   }

   bool interaction_impl::AnimateWindow(millis millis, u32 dwFlags)
   {
      ASSERT(::is_window(get_handle()));
      return ::AnimateWindow(get_handle(), __os(millis), dwFlags) != FALSE;
   }

   bool interaction_impl::FlashWindowEx(u32 dwFlags, UINT  uCount, millis tickTimeout)
   {
      ASSERT(::is_window(get_handle()));
      FLASHWINFO fwi;
      fwi.cbSize = sizeof(fwi);
      fwi.hwnd = get_handle();
      fwi.dwFlags = dwFlags;
      fwi.uCount = uCount;
      fwi.dwTimeout = __os(tickTimeout);

      return ::FlashWindowEx(&fwi) != FALSE;
   }



   bool interaction_impl::SetLayeredWindowAttributes(COLORREF crKey, BYTE bAlpha, u32 dwFlags)
   {
      ASSERT(::is_window(get_handle()));
      return ::SetLayeredWindowAttributes(get_handle(), crKey, bAlpha, dwFlags) != FALSE;
   }

   bool interaction_impl::UpdateLayeredWindow(::draw2d::graphics * pDCDst, POINT *pptDst, SIZE *psize,
         ::draw2d::graphics * pDCSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, u32 dwFlags)
   {
      ASSERT(::is_window(get_handle()));
      ::exception::throw_not_implemented();
      return false;
      /*      return ::UpdateLayeredWindow(get_handle(), WIN_HDC(pDCDst), pptDst, psize,
      WIN_HDC(pDCSrc), pptSrc, crKey, pblend, dwFlags) != FALSE;*/
   }


   bool interaction_impl::GetLayeredWindowAttributes(COLORREF *pcrKey, BYTE *pbAlpha, u32 *pdwFlags) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      return ::GetLayeredWindowAttributes(((interaction_impl *)this)->get_handle(), pcrKey, pbAlpha, (LPDWORD)pdwFlags) != FALSE;
   }

   bool interaction_impl::PrintWindow(::draw2d::graphics_pointer & pgraphics, UINT nFlags) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      ::exception::throw_not_implemented();
      //      return ::PrintWindow(get_handle(), (HDC)(dynamic_cast<::windows::graphics * >(pgraphics))->get_handle(), nFlags) != FALSE;
      return false;
   }


   LRESULT interaction_impl::OnNTCtlColor(WPARAM wParam, LPARAM lParam)
   {
      // fill in special struct for compatiblity with 16-bit WM_CTLCOLOR
      __CTLCOLOR ctl;
      ctl.hDC = (HDC)wParam;
      ctl.oswindow = (oswindow)lParam;
      return 0;
   }

   /////////////////////////////////////////////////////////////////////////////
   // interaction_impl extensions for help support

   void interaction_impl::WinHelp(uptr dwData, UINT nCmd)
   {
      UNREFERENCED_PARAMETER(dwData);
      UNREFERENCED_PARAMETER(nCmd);
      ::exception::throw_not_implemented();

      /*      application* pApp = System;
      ASSERT_VALID(pApp);
      ASSERT(pApp->m_pszHelpFilePath != nullptr);
      ASSERT(pApp->m_eHelpType == afxWinHelp);

      wait_cursor wait(m_pobject);

      PrepareForHelp();

      // need to use top level parent (for the case where get_handle() is in DLL)
      __pointer(::user::interaction) pwindow = EnsureTopLevelParent();

      information(trace_category_appmsg, trace_level_warning, "WinHelp: pszHelpFile = '%s', dwData: $%lx, fuCommand: %d.\n", pApp->m_pszHelpFilePath, dwData, nCmd);

      // finally, run the Windows Help engine
      /* trans   if (!::WinHelp((pwindow)->get_handle(), pApp->m_pszHelpFilePath, nCmd, dwData))
      {
      // linux System.message_box(__IDP_FAILED_TO_LAUNCH_HELP);
      System.message_box("Failed to launch help");
      }*/
   }

   //void interaction_impl::HtmlHelp(uptr dwData, UINT nCmd)
   //{
   // ::exception::throw_not_implemented();
   /*
   application* pApp = System;
   ASSERT_VALID(pApp);
   ASSERT(pApp->m_pszHelpFilePath != nullptr);
   // to call HtmlHelp the m_fUseHtmlHelp must be set in
   // the application's constructor
   ASSERT(pApp->m_eHelpType == afxHTMLHelp);

   wait_cursor wait(m_pobject);

   PrepareForHelp();

   // need to use top level parent (for the case where get_handle() is in DLL)
   __pointer(::user::interaction) pwindow = EnsureTopLevelParent();

   information(trace_category_appmsg, trace_level_warning, "HtmlHelp: pszHelpFile = '%s', dwData: $%lx, fuCommand: %d.\n", pApp->m_pszHelpFilePath, dwData, nCmd);

   // run the HTML Help engine
   /* trans   if (!::aura::HtmlHelp((pwindow)->get_handle(), pApp->m_pszHelpFilePath, nCmd, dwData))
   {
   // linux System.message_box(__IDP_FAILED_TO_LAUNCH_HELP);
   System.message_box("Failed to launch help");
   }*/
   //}

   void interaction_impl::PrepareForHelp()
   {

      __pointer(::user::interaction) pFrameWnd = m_puserinteraction;

      if (pFrameWnd.is_set())
      {

         // frame_window windows should be allowed to exit help mode first

         pFrameWnd->ExitHelpMode();

      }

      // cancel any tracking modes
      send_message(WM_CANCELMODE);
      send_message_to_descendants(WM_CANCELMODE, 0, 0, TRUE, TRUE);

      // need to use top level parent (for the case where get_handle() is in DLL)
      __pointer(::user::interaction) pwindow = EnsureTopLevel();
      (pwindow.m_p)->send_message(WM_CANCELMODE);
      (pwindow.m_p)->send_message_to_descendants(WM_CANCELMODE, 0, 0, TRUE, TRUE);

      // attempt to cancel capture
      oswindow oswindow_Capture = ::GetCapture();
      if (oswindow_Capture != nullptr)
         ::SendMessage(oswindow_Capture, WM_CANCELMODE, 0, 0);
   }


   void interaction_impl::WinHelpInternal(uptr dwData, UINT nCmd)
   {
      UNREFERENCED_PARAMETER(dwData);
      UNREFERENCED_PARAMETER(nCmd);
      ::exception::throw_not_implemented();
      /*
      application* pApp = System;
      ASSERT_VALID(pApp);
      if (pApp->m_eHelpType == afxHTMLHelp)
      {
      // translate from WinHelp commands and data to to HtmlHelp
      ASSERT((nCmd == HELP_CONTEXT) || (nCmd == HELP_CONTENTS) || (nCmd == HELP_FINDER));
      if (nCmd == HELP_CONTEXT)
      nCmd = HH_HELP_CONTEXT;
      else if (nCmd == HELP_CONTENTS)
      nCmd = HH_DISPLAY_TOC;
      else if (nCmd == HELP_FINDER)
      nCmd = HH_HELP_FINDER;
      HtmlHelp(dwData, nCmd);
      }
      else
      WinHelp(dwData, nCmd);*/
   }



   void interaction_impl::route_command_message(::user::command * pcommand)
   {

      channel::route_command_message(pcommand);

      if (pcommand->m_bRet)
         return;

      channel * pcmdtarget = dynamic_cast <channel *> (this);

      pcmdtarget->channel::route_command_message(pcommand);

   }



   void interaction_impl::message_handler(::message::base * pbase)
   {

      const ::id & id;

      emessage = UINT(pbase->m_id.::huge_integer());

      m_uiMessage = emessage;
      m_wparam = pbase->m_wparam;
      m_lparam = pbase->m_lparam;

      if (emessage == e_message_nccalcsize)
      {

         output_debug_string("e_message_nccalcsize");

      }

      //if(emessage == e_message_mouse_move)
      //{
      //
      //   pbase->m_bRet = true;
      //   //pbase->set_lresult(1);
      //   // addictive human (camilo, you are classifying yourself human, you're kind respecting yourself, its a good sign...) profiling with PROFILE_MOVE_MANAGER at app_core_miau.vcxproj...

      //   return;


      //}


      bool bUserElementalOk = !m_bDestroyImplOnly && m_puserinteraction->m_bUserPrimitiveOk;

      if (emessage == e_message_enable)
      {

         //informationf("e_message_enable enable = " + string(pbase->m_wparam ? "true" : "false"));

      }
      if (emessage == WM_GETTEXTLENGTH)
      {

         //informationf("WM_GETTEXTLENGTH");

      }
      if (emessage == WM_GETTEXT)
      {

         //informationf("WM_GETTEXT");

      }
      if (emessage == e_message_create)
      {

         //informationf("e_message_create");

      }
      if (emessage == e_message_nccreate)
      {

         //informationf("e_message_nccreate");

      }
      if (emessage == e_message_size || emessage == e_message_move)
      {

         //win_update_graphics();

      }

      if (emessage == e_message_key_down ||
            emessage == e_message_key_up ||
            emessage == e_message_char ||
            emessage == e_message_sys_key_down ||
            emessage == e_message_sys_key_up ||
            emessage == e_message_sys_char ||
            emessage == WM_IME_KEYDOWN ||
            emessage == WM_IME_KEYUP ||
            emessage == WM_IME_CHAR ||
            emessage == WM_IME_STARTCOMPOSITION ||
            emessage == WM_IME_COMPOSITION ||
            emessage == WM_IME_COMPOSITIONFULL ||
            emessage == WM_IME_NOTIFY ||
            emessage == WM_IME_ENDCOMPOSITION)
      {

         if (emessage == WM_IME_STARTCOMPOSITION)
         {
            output_debug_string("WM_IME_STARTCOMPOSITION");
         }

         if (emessage == WM_IME_NOTIFY)
         {
            output_debug_string("WM_IME_NOTIFY");
         }


         SCAST_PTR(::message::key, pkey, pbase);

         if (emessage == e_message_key_down)
         {

            output_debug_string("\n Key Down Event ");

         }

         if (emessage == e_message_key_down || emessage == e_message_sys_key_down)
         {
            try
            {
               Session.set_key_pressed(pkey->m_ekey, true);
            }
            catch (...)
            {
            }
         }
         else if (emessage == e_message_key_up || emessage == e_message_sys_key_up)
         {

            try
            {

               Session.set_key_pressed(pkey->m_ekey, false);

            }
            catch (...)
            {

            }

         }

      }

      //if (m_puserinteraction != nullptr)
      //{

      //   if (m_puserinteraction->window_is_moving())
      //   {
      //      //informationf("moving: skip pre translate message");
      //   }
      //   else if (m_puserinteraction->window_is_sizing())
      //   {
      //      //informationf("sizing: skip pre translate message");
      //   }
      //   else
      //   {

      //      m_puserinteraction->pre_translate_message(pbase);

      //      if (pbase->m_bRet)
      //         return;

      //      pbase->m_uiMessageFlags |= 1;

      //   }
      //}

      if (emessage == e_message_timer)
      {
         //         m_puserinteraction->m_papp->step_timer();
      }
      else if (emessage == e_message_left_button_down)
      {
         ::rectangle_i32 rectClient;
         ::GetClientRect(get_handle(), rectClient);
         ::rectangle_i32 rectWindow;
         ::GetWindowRect(get_handle(), rectWindow);
         ::rectangle_i32 rectRegion;
         HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
         int regionType = ::GetWindowRgn(get_handle(), hrgn);
         if (regionType != ERROR)
         {
            ::GetRgnBox(hrgn, rectRegion);
         }
         ::DeleteObject(hrgn); /* finished with region */
         WINDOWPLACEMENT wp;
         ·zero(wp);
         wp.length = sizeof(WINDOWPLACEMENT);
         ::GetWindowPlacement(get_handle(), &wp);
         bool bZoomed = ::IsZoomed(get_handle()) != FALSE;
         bool bIconic = ::IsIconic(get_handle()) != FALSE;
      }
      else if (emessage == e_message_mouse_move)
      {
         //output_debug_string("\nMMV");
      }
      else if(emessage == e_message_set_cursor
               || emessage == e_message_non_client_mouse_move)
      {
         //output_debug_string(".");
      }
      else
      {
#ifdef DEBUG

         if (0)
         {
            switch (emessage)
            {
            case e_message_create:
               informationf("e_message_create wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_window_position_changing:
               informationf("e_message_window_position_changing wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_window_position_changed:
               informationf("e_message_window_position_changed wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_activate:
               informationf("e_message_activate wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case WM_ACTIVATEAPP:
               informationf("WM_ACTIVATEAPP wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_mouse_activate:
               informationf("e_message_mouse_activate wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_ncactivate:
               informationf("e_message_ncactivate wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_set_focus:
               informationf("e_message_set_focus wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_kill_focus:
               informationf("e_message_kill_focus wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_move:
               informationf("e_message_move wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            case e_message_size:
               informationf("e_message_size wparam=%08x lparam=%08x", pbase->m_wparam, pbase->m_lparam);

               break;
            default:
               informationf("MESSAGE %08x wparam=%08x lparam=%08x", emessage, pbase->m_wparam, pbase->m_lparam);

               break;
            }

         }

#endif
      }

      /*      else if(emessage == CA2M_BERGEDGE)
      {
      if(pbase->m_wparam == BERGEDGE_GETAPP)
      {
      __pointer(::aura::application)* ppapp= (__pointer(::aura::application)*) pbase->m_lparam;
      *ppapp = get_app();
      pbase->m_bRet = true;
      return;
      }
      }*/
      pbase->set_lresult(0);

      if (emessage == e_message_mouse_leave)
      {

         _000OnMouseLeave(pbase);

         return;

      }

      if (emessage == e_message_left_button_down ||
            emessage == e_message_left_button_up ||
            emessage == e_message_middle_button_down ||
            emessage == e_message_middle_button_up ||
            emessage == e_message_right_button_down ||
            emessage == e_message_right_button_up ||
            emessage == e_message_left_button_double_click ||
            emessage == e_message_mouse_move ||
            emessage == e_message_non_client_mouse_move ||
            emessage == e_message_mouse_wheel)
      {

         message::mouse * pmouse = dynamic_cast <::message::mouse * > (pbase);

         Session.on_ui_mouse_message(pmouse);

         if (m_bTranslateMouseMessageCursor && !pmouse->m_bTranslated)
         {
            pmouse->m_bTranslated = true;
            ::rectangle_i32 rectWindow;
            // People always ask for feature centric Flag/Macros...
            // ok, sometimes we attend them, besides it is easier to name the pigs...
            // (but I like pigs... and the porks... :-)
            if (m_bScreenRelativeMouseMessagePosition)
            {
               ::rectangle_i32 rectWindow32;
               ::GetWindowRect(get_handle(), rectWindow32);
               ::copy(rectWindow, rectWindow32);
            }
            else
            {
               m_puserinteraction->window_rectangle(rectWindow);
            }

            pmouse->m_point.x += (LONG)rectWindow.left;

            pmouse->m_point.y += (LONG)rectWindow.top;

         }


         if (emessage == e_message_left_button_down)
         {

            informationf("e_message_left_button_down");

         }


         if (emessage == e_message_mouse_move)
         {
            // We are at the message handler procedure.
            // mouse messages originated from message handler and that are mouse move events should end up with the correct cursor.
            // So the procedure starts by setting to the default cursor,
            // what forces, at the end of message processing, setting the bergedge cursor to the default cursor, if no other
            // handler has set it to another one.
            pmouse->m_ecursor = cursor_default;
         }
         else if (emessage == e_message_non_client_mouse_move)
         {
            // We are at the message handler procedure.
            // mouse messages originated from message handler and that are mouse move events should end up with the correct cursor.
            // So the procedure starts by setting to the default cursor,
            // what forces, at the end of message processing, setting the bergedge cursor to the default cursor, if no other
            // handler has set it to another one.
            pmouse->m_ecursor = cursor_default;
         }

         if (Session.m_puiCapture != nullptr)
         {

            Session.m_puiCapture->_000OnMouse(pmouse);

            return;

         }

         _008OnMouse(pmouse);

         return;

      }

      if (emessage == MESSAGE_OLE_DRAGENTER ||
            emessage == MESSAGE_OLE_DRAGOVER ||
            emessage == MESSAGE_OLE_DRAGLEAVE ||
            emessage == MESSAGE_OLE_DRAGDROP)
      {

         message::drag_and_drop * pdrag = (::message::drag_and_drop *) pbase;


         user::oswindow_array oswindowa;
         user::interaction_pointer_array wnda;
         wnda = *System.m_puiptraFrame;
         oswindowa = wnda.get_hwnda();
         user::window_util::SortByZOrder(oswindowa);
         for (i32 i = 0; i < oswindowa.get_size(); i++)
         {
            __pointer(::user::interaction) puserinteraction = wnda.find_first(oswindowa[i]);
            if (puserinteraction != nullptr)
            {
               puserinteraction->_000OnDrag(pdrag);
               if (pdrag->m_bRet)
                  return;
            }
         }
         return;
      }
      if (emessage == e_message_key_down ||
            emessage == e_message_key_up ||
            emessage == e_message_char ||
            emessage == e_message_sys_key_down ||
            emessage == e_message_sys_key_up ||
            emessage == e_message_sys_char ||
            emessage == WM_IME_KEYDOWN ||
            emessage == WM_IME_KEYUP ||
            emessage == WM_IME_CHAR ||
            emessage == WM_IME_STARTCOMPOSITION ||
            emessage == WM_IME_COMPOSITION ||
            emessage == WM_IME_COMPOSITIONFULL ||
            emessage == WM_IME_NOTIFY ||
            emessage == WM_IME_ENDCOMPOSITION )
      {

         message::key * pkey = (::message::key *) pbase;

         __pointer(::user::interaction) puiFocus = Session.get_keyboard_focus();

         if (emessage == WM_IME_STARTCOMPOSITION)
         {
            output_debug_string("WM_IME_STARTCOMPOSITION");
         }
         else if (emessage == WM_IME_NOTIFY)
         {
            output_debug_string("WM_IME_NOTIFY");
         }
         else if (emessage == e_message_char)
         {
            output_debug_string("e_message_char");
         }

         if (puiFocus && puiFocus->is_window() && puiFocus != m_puserinteraction)
         {

            puiFocus->send(pkey);

            if (pbase->m_bRet)
               return;

         }
         else if (!pkey->m_bRet)
         {

            if (m_puserinteraction != nullptr)
            {

               m_puserinteraction->_000OnKey(pkey);

               if (pbase->m_bRet)
                  return;

            }

         }

         pbase->set_lresult(DefWindowProc(emessage, pbase->m_wparam, pbase->m_lparam));

         return;

      }

      if (emessage == e_message_event)
      {

         m_puserinteraction->on_control_event(pbase);

         return;

      }

      ::user::interaction_impl::message_handler(pbase);

//if(pmessage->m_bRet && !pbase->m_bDoSystemDefault)

      if (pbase->m_bRet)
      {

         return;

      }

      if (bUserElementalOk)
      {
         if (m_puserinteraction != nullptr)
         {
            pbase->set_lresult(m_puserinteraction->DefWindowProc(emessage, pbase->m_wparam, pbase->m_lparam));
         }
         else
         {
            pbase->set_lresult(DefWindowProc(emessage, pbase->m_wparam, pbase->m_lparam));
         }
      }
   }


   bool interaction_impl::OnCommand(::message::base * pbase)
   {
      UNREFERENCED_PARAMETER(pbase);
      return FALSE;
   }


   bool interaction_impl::OnNotify(::message::base * pbase)
   {

      ASSERT(pbase != nullptr);
      NMHDR* pNMHDR = pbase->m_lparam.cast < NMHDR>();
      oswindow oswindow_Ctrl = pNMHDR->hwndFrom;

      // get the child ID from the interaction_impl itself
      //      uptr nID = __get_dialog_control_id(oswindow_Ctrl);
      //      i32 nCode = pNMHDR->code;

      ASSERT(oswindow_Ctrl != nullptr);
      ASSERT(::is_window(oswindow_Ctrl));

      //      if (gen_ThreadState->m_hLockoutNotifyWindow == get_handle())
      //       return true;        // locked out - ignore control notification

      // reflect notification to child interaction_impl control
      if (ReflectMessage(oswindow_Ctrl, pbase))
         return true;        // eaten by child

      //      __NOTIFY notify;
      //    notify.pResult = pResult;
      //  notify.pNMHDR = pNMHDR;
      //xxx   return _001OnCommand(pbase);
      return false;
   }




   bool interaction_impl::IsTopParentActive()
   {
      ASSERT(get_handle() != nullptr);
      ASSERT_VALID(this);

      __pointer(::user::interaction)pWndTopLevel = EnsureTopLevel();

      return interaction_impl::GetForegroundWindow() == pWndTopLevel->GetLastActivePopup();
   }

   void interaction_impl::ActivateTopParent()
   {
      // special activate logic for floating toolbars and palettes
      ::window_sp pActiveWnd = GetForegroundWindow();
      if (!pActiveWnd || !((pActiveWnd)->get_handle() == get_handle() || ::IsChild((pActiveWnd)->get_handle(), get_handle())))
      {
         // clicking on floating frame when it does not have
         // focus itself -- activate the toplevel frame instead.
         EnsureTopLevel()->SetForegroundWindow();
      }
   }



   i32 interaction_impl::message_box(const char * pszText, const char * pszCaption, UINT nType)

   {
      if (pszCaption == nullptr)

         pszCaption = Application.m_strAppName;

      i32 nResult = ::message_box(get_handle(), pszText, pszCaption, nType);

      return nResult;
   }



   i32 interaction_impl::SetScrollPos(i32 nBar, i32 nPos, bool bRedraw)
   {
      return ::SetScrollPos(get_handle(), nBar, nPos, bRedraw);
   }

   i32 interaction_impl::GetScrollPos(i32 nBar) const
   {
      return ::GetScrollPos(((::windows::interaction_impl *)this)->get_handle(), nBar);
   }

   void interaction_impl::SetScrollRange(i32 nBar, i32 nMinPos, i32 nMaxPos, bool bRedraw)
   {
      ::SetScrollRange(get_handle(), nBar, nMinPos, nMaxPos, bRedraw);
   }

   void interaction_impl::GetScrollRange(i32 nBar, LPINT pMinPos, LPINT lpMaxPos) const

   {
      ::GetScrollRange(((::windows::interaction_impl *)this)->get_handle(), nBar, pMinPos, lpMaxPos);

   }

// Turn on/off non-control scrollbars
//   for WS_?SCROLL scrollbars - show/hide them
//   for control scrollbar - enable/disable them
   void interaction_impl::EnableScrollBarCtrl(i32 nBar, bool bEnable)
   {
      // WS_?SCROLL scrollbar - show or hide
      ShowScrollBar(nBar, bEnable);
   }

   bool interaction_impl::SetScrollInfo(i32 nBar, LPSCROLLINFO pScrollInfo, bool bRedraw)

   {
      ASSERT(pScrollInfo != nullptr);


      oswindow oswindow = get_handle();
      pScrollInfo->cbSize = sizeof(*pScrollInfo);

      ::SetScrollInfo(oswindow, nBar, pScrollInfo, bRedraw);

      return true;
   }

   bool interaction_impl::GetScrollInfo(i32 nBar, LPSCROLLINFO pScrollInfo, UINT nMask)

   {
      UNREFERENCED_PARAMETER(nMask);
      ASSERT(pScrollInfo != nullptr);


      oswindow oswindow = get_handle();
      return ::GetScrollInfo(oswindow, nBar, pScrollInfo) != FALSE;

   }

   i32 interaction_impl::GetScrollLimit(i32 nBar)
   {
      i32 nMin, nMax;
      GetScrollRange(nBar, &nMin, &nMax);
      SCROLLINFO info;
      if (GetScrollInfo(nBar, &info, SIF_PAGE))
      {
         nMax -= __max(info.nPage - 1, 0);
      }
      return nMax;
   }

   void interaction_impl::ScrollWindow(i32 xAmount, i32 yAmount,
      LPCRECT rect, LPCRECT lpClipRect)

   {
      //ASSERT(::is_window(get_handle()));

      //if(is_window_visible() || prect != nullptr || lpClipRect != nullptr)

      //{
      //   // When visible, let Windows do the scrolling
      //   ::ScrollWindow(get_handle(),xAmount,yAmount,prect,lpClipRect);

      //}
      //else
      //{
      //   // Windows does not perform any scrolling if the interaction_impl is
      //   // not visible.  This leaves child windows unscrolled.
      //   // To ac::count for this oversight, the child windows are moved
      //   // directly instead.
      //   oswindow oswindow_Child = ::GetWindow(get_handle(),GW_CHILD);
      //   if(oswindow_Child != nullptr)
      //   {
      //      for(; oswindow_Child != nullptr;
      //            oswindow_Child = ::GetNextWindow(oswindow_Child,GW_HWNDNEXT))
      //      {
      //         ::rectangle_i32 rect;
      //         ::window_rectangle(oswindow_Child,&rect);
      //         screen_to_client(&rect);
      //         ::set_window_pos(oswindow_Child,nullptr,rect.left + xAmount,rect.top + yAmount,0,0,SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
      //      }
      //   }
      //}

   }


   void interaction_impl::CalcWindowRect(RECT * pClientRect, UINT nAdjustType)
   {

      u32 dwExStyle = GetExStyle();
      if (nAdjustType == 0)
         dwExStyle &= ~WS_EX_CLIENTEDGE;
      ::AdjustWindowRectEx(pClientRect, GetStyle(), FALSE, dwExStyle);

   }


   bool interaction_impl::HandleFloatingSysCommand(UINT nID, LPARAM lParam)
   {

      __pointer(::user::interaction) pParent = GetTopLevel();

      switch (nID & 0xfff0)
      {
      case SC_PREVWINDOW:
      case SC_NEXTWINDOW:
         if (LOWORD(lParam) == VK_F6 && pParent)
         {
            pParent->SetFocus();
            return true;
         }
         break;

      case SC_CLOSE:
      case SC_KEYMENU:
         // Check lParam.  If it is 0L, then the ::account::user may have done
         // an Alt+Tab, so just ignore it.  This breaks the ability to
         // just press the Alt-key and have the first menu selected,
         // but this is minor compared to what happens in the Alt+Tab
         // case.
         if ((nID & 0xfff0) == SC_CLOSE || lParam != 0L)
         {
            if (pParent)
            {
               // Sending the above WM_SYSCOMMAND may destroy the cast,
               // so we have to be careful about restoring activation
               // and focus after sending it.
               oswindow oswindow_Save = get_handle();
               oswindow oswindow_Focus = ::GetFocus();
               pParent->SetActiveWindow();
               pParent->send_message(WM_SYSCOMMAND, nID, lParam);

               // be very careful here...
               if (::is_window(oswindow_Save))
                  ::set_active_window(oswindow_Save);
               if (::is_window(oswindow_Focus))
                  ::set_focus(oswindow_Focus);
            }
         }
         return true;
      }
      return false;
   }

   bool interaction_impl::ReflectMessage(oswindow oswindow_Child, ::message::base * pbase)
   {

      // check if in permanent map, if it is reflect it (could be OLE control)
      ::window_sp pwindow = System.ui_from_handle(oswindow_Child);
      ASSERT(!pwindow || (pwindow)->get_handle() == oswindow_Child);
      if (!pwindow)
      {
         return FALSE;
      }

      // only OLE controls and permanent windows will get reflected msgs
      ASSERT(pwindow);
      return (pwindow)->OnChildNotify(pbase);
   }

   bool interaction_impl::OnChildNotify(::message::base * pbase)
   {

      return ReflectChildNotify(pbase);
   }

   bool interaction_impl::ReflectChildNotify(::message::base * pbase)
   {

      // Note: reflected messages are send directly to interaction_impl::OnWndMsg
      //  and interaction_impl::_001OnCommand for speed and because these messages are not
      //  routed by normal _001OnCommand routing (they are only dispatched)

      const ::id & id;

      emessage = UINT(pbase->m_id.::huge_integer());

      switch (emessage)
      {
      // normal messages (just wParam, lParam through OnWndMsg)
      case e_message_scroll_x:
      case e_message_scroll_y:
      case WM_PARENTNOTIFY:
      case WM_DRAWITEM:
      case e_message_measure_item:
      case WM_DELETEITEM:
      case WM_VKEYTOITEM:
      case WM_CHARTOITEM:
      case WM_COMPAREITEM:
         // reflect the message through the message map as WM_REFLECT_BASE+uMsg
         //return interaction_impl::OnWndMsg(WM_REFLECT_BASE+uMsg, wParam, lParam, pResult);
         return FALSE;

      // special case for e_message_command
      case e_message_command:
      {
         // reflect the message through the message map as OCM_COMMAND
         __keep(&pbase->m_bReflect, true);

         if (interaction_impl::OnCommand(pbase))
         {
            pbase->m_bRet = true;
            return true;
         }
      }
      break;

      // special case for WM_NOTIFY
      case WM_NOTIFY:
      {
         // reflect the message through the message map as OCM_NOTIFY
         NMHDR* pNMHDR = pbase->m_lparam.cast < NMHDR >();
         //            i32 nCode = pNMHDR->code;
         //            __NOTIFY notify;
         //          notify.pResult = pResult;
         //        notify.pNMHDR = pNMHDR;
         // xxxx         return interaction_impl::_001OnCommand(0, MAKELONG(nCode, WM_REFLECT_BASE+WM_NOTIFY), &notify, nullptr);
      }

      // other special cases (WM_CTLCOLOR family)
      default:
         if (emessage >= WM_CTLCOLORMSGBOX && emessage <= WM_CTLCOLORSTATIC)
         {
            // fill in special struct for compatiblity with 16-bit WM_CTLCOLOR
            /*__CTLCOLOR ctl;
            ctl.hDC = (HDC)wParam;
            ctl.nCtlType = uMsg - WM_CTLCOLORMSGBOX;
            //ASSERT(ctl.nCtlType >= CTLCOLOR_MSGBOX);
            ASSERT(ctl.nCtlType <= CTLCOLOR_STATIC);

            // reflect the message through the message map as OCM_CTLCOLOR
            bool bResult = interaction_impl::OnWndMsg(WM_REFLECT_BASE+WM_CTLCOLOR, 0, (LPARAM)&ctl, pResult);
            if ((HBRUSH)*pResult == nullptr)
            bResult = FALSE;
            return bResult;*/
            return false;
         }
         break;
      }

      return false;   // let the parent handle it
   }

   void interaction_impl::OnParentNotify(const ::id & id, LPARAM lParam)
   {
      if ((LOWORD(message) == e_message_create || LOWORD(message) == e_message_destroy))
      {
         //if (ReflectMessage((oswindow) lParam))
         // return;     // eat it
      }
      // not handled - do default
      Default();
   }

//void interaction_impl::_001OnSetFocus(::message::message * pdetails)
//{
//
//   //bool bHandled;

//   //bHandled = FALSE;
//   //if(!bHandled)
//   //{
//   //   Default();
//   //}



//}


   LRESULT interaction_impl::OnActivateTopLevel(WPARAM wParam, LPARAM)
   {

      return 0;

   }


   void interaction_impl::OnSysColorChange()
   {
      ::exception::throw_not_implemented();

      /*      application* pApp = System;
      if (pApp != nullptr && pApp->m_puiMain == this)
      {
      // recolor global brushes used by control bars
      afxData.UpdateSysColors();
      }

      // forward this message to all other child windows
      if (!(GetStyle() & WS_CHILD))
      send_message_to_descendants(WM_SYSCOLORCHANGE, 0, 0L, TRUE, TRUE);

      Default();*/
   }

   bool gen_GotScrollLines;

   void interaction_impl::OnSettingChange(UINT uFlags, const char * pszSection)

   {
      UNUSED_ALWAYS(uFlags);
      UNUSED_ALWAYS(pszSection);


      // force refresh of settings that we cache
      gen_GotScrollLines = FALSE;


      interaction_impl::OnDisplayChange(0, 0);    // to update system metrics, etc.
   }

   void interaction_impl::OnDevModeChange(__in char * pDeviceName)

   {
      UNREFERENCED_PARAMETER(pDeviceName);

      ::exception::throw_not_implemented();
      /*application* pApp = System;
      if (pApp != nullptr && pApp->m_puiMain == this)
      pApp->DevModeChange(pDeviceName);


      // forward this message to all other child windows
      if (!(GetStyle() & WS_CHILD))
      {
      const MSG* pMsg = GetCurrentMessage();
      send_message_to_descendants(pMsg->message, pMsg->wParam, pMsg->lParam,
      TRUE, TRUE);
      }*/
   }

   bool interaction_impl::OnHelpInfo(HELPINFO* /*pHelpInfo*/)
   {
      return Default() != 0;
   }

   LRESULT interaction_impl::OnDisplayChange(WPARAM wparam, LPARAM lparam)

   {

      // forward this message to all other child windows
      if (!(GetStyle() & WS_CHILD))
      {
         //         const MSG* pMsg = GetCurrentMessage();
         send_message_to_descendants(e_message_display_change, wparam, lparam, TRUE, TRUE);

      }

      return Default();
   }

   LRESULT interaction_impl::OnDragList(WPARAM, LPARAM lParam)
   {
      LPDRAGLISTINFO pInfo = (LPDRAGLISTINFO)lParam;

      ASSERT(pInfo != nullptr);


      //      LRESULT lResult;
      //if (ReflectLastMsg(pInfo->hWnd, &lResult))

      //   return (i32)lResult;    // eat it

      // not handled - do default
      return (i32)Default();
   }


   void interaction_impl::_002OnDraw(image image)
   {

      ::exception::throw_not_implemented();
      //::CallWindowProc(*GetSuperWndProcAddr(), get_handle(), WM_PRINT, (WPARAM)((dynamic_cast<::windows::graphics * >(pgraphics))->get_handle()), (LPARAM)(PRF_CHILDREN | PRF_CLIENT));

   }


   void interaction_impl::present()
   {

      _001UpdateWindow();

   }


   //void interaction_impl::defer_start_prodevian()
   //{


   //   ::user::interaction_impl::defer_start_prodevian();


   //}


   void interaction_impl::_001OnCreate(::message::message * pmessage)
   {

      SCAST_PTR(::message::create, pcreate, pmessage);

      {

         DEVMODE dm;

         if (EnumDisplaySettings(nullptr, ENUM_CURRENT_SETTINGS, &dm))
         {

            set_config_fps(dm.dmDisplayFrequency);

         }

      }

      Default();

      if (m_puserinteraction->is_message_only_window()
            || dynamic_cast <::user::system_interaction_impl *>(m_puserinteraction) != nullptr)
      {

         informationf("good : opt out!");

      }

      if (m_puserinteraction->m_bUserPrimitiveOk)
      {

         pcreate->set_lresult(0);

      }

   }


   BOOL CALLBACK GetAppsEnumWindowsProc(oswindow oswindow, LPARAM lParam);


   BOOL CALLBACK GetAppsEnumWindowsProc(oswindow oswindow, LPARAM lParam)
   {

      user::oswindow_array * poswindowa = (user::oswindow_array *) lParam;

      poswindowa->add(oswindow);

      return TRUE;

   }

   void interaction_impl::get_app_wnda(user::oswindow_array & wnda)
   {
      EnumWindows(GetAppsEnumWindowsProc, (LPARAM)&wnda);
   }


   class print_window :
      virtual public ::object
   {
   public:



      manual_reset_event m_event;
      oswindow m_oswindow;
      HDC m_hdc;

      print_window(::particle * pparticle, oswindow oswindow, HDC hdc, millis tickTimeout) :
         ::object(pobject)
      {

         m_oswindow = oswindow;

         m_hdc = hdc;

         fork();

         if (m_event.wait(tickTimeout).timeout())
         {

            informationf("print_window::time_out");

         }

      }


      virtual e_status run() override
      {

         try
         {

            ::PrintWindow(m_oswindow, m_hdc, 0);

         }
         catch (...)
         {

         }

         m_event.set_event();



         return success;

      }

   };

   void interaction_impl::_001DeferPaintLayeredWindowBackground(HDC hdc)
   {

   }


   void interaction_impl::_001OnProdevianSynch(::message::message * pmessage)
   {

      UNREFERENCED_PARAMETER(pmessage);

   }


   void interaction_impl::_001OnPaint(::message::message * pmessage)
   {

      if (GetExStyle() & WS_EX_LAYERED)
      {


         return;

      }

      SCAST_PTR(::message::base, pbase, pmessage);

      ::rectangle_i32 rectWindow;

      m_puserinteraction->window_rectangle(rectWindow);

      PAINTSTRUCT paint;

      memset_dup(&paint, 0, sizeof(paint));

      HDC hdc = ::BeginPaint(get_handle(), &paint);

      ::SelectClipRgn(hdc, nullptr);

      ::rectangle_i32 rectPaint;

      ::rectangle_i32 rectUpdate;

      rectPaint = paint.rcPaint;

      if (rectPaint.is_null() || (GetExStyle() & WS_EX_LAYERED))
      {

         rectUpdate = rectWindow;

         rectPaint = rectWindow;

         m_puserinteraction->screen_to_client(rectPaint);

      }
      else
      {

         rectUpdate = rectPaint;

      }

      if (m_spgraphics.is_null())
      {

         update_graphics_resources();

      }

      __pointer(::windows::window_buffer) pbuffer = m_spgraphics;

      ASSERT(pbuffer.is_set());

      single_lock sl(pbuffer->m_pmutex);



      ::BitBlt(hdc, rectUpdate.left, rectUpdate.top, rectUpdate.width(), rectUpdate.height(),
         pbuffer->m_hdc, 0, 0);

      //if (m_spgraphics.is_set())
      //{

      //   ::draw2d::graphics_pointer & pgraphics = m_spgraphics->on_begin_draw();

      //   if (pgraphics != nullptr)
      //   {

      //      try
      //      {

      //         _001Print(pgraphics);

      //      }
      //      catch (...)
      //      {


      //      }

      //      ::draw2d::graphics_sp g(e_create_new, this);

      //      try
      //      {

      //         if (pgraphics != nullptr && g->attach_hdc(hdc))
      //         {

      //            pgraphics->SetViewportOrg(0, 0);

      //            g->BitBlt(rectPaint.left, rectPaint.top, rectPaint.width(), rectPaint.height(), pgraphics, rectUpdate.left, rectUpdate.top);

      //         }

      //      }
      //      catch (...)
      //      {

      //      }

      //   }

      //}

      ::EndPaint(get_handle(), &paint);

      pmessage->m_bRet = true;

      pbase->set_lresult(0);

   }


   void interaction_impl::_001OnPrint(::message::message * pmessage)
   {

      //      if(m_image.is_null())
      //       m_image.alloc(this);

      //m_image.print_window(this,pmessage);

      //m_spimageBuffer.print_window(this, pmessage);

   }


   void interaction_impl::OnEnterIdle(UINT /*nWhy*/, ::window_sp /*pWho*/)
   {
      // In some OLE inplace active scenarios, OLE will post a
      // message instead of sending it.  This causes so many WM_ENTERIDLE
      // messages to be sent that tasks running in the background stop
      // running.  By dispatching the pending WM_ENTERIDLE messages
      // when the first one is received, we trick Windows into thinking
      // that only one was really sent and dispatched.
      {
         MSG msg;
         while (PeekMessage(&msg, nullptr, WM_ENTERIDLE, WM_ENTERIDLE, PM_REMOVE))
            DispatchMessage(&msg);
      }

      Default();
   }

   HBRUSH interaction_impl::OnCtlColor(::draw2d::graphics *, ::window_sp pwindow, UINT)
   {
      ASSERT(pwindow && (pwindow)->get_handle() != nullptr);
      //      LRESULT lResult;
      //if ((pwindow)->OnChildNotify(&lResult))
      //   return (HBRUSH)lResult;     // eat it
      return (HBRUSH)Default();
   }

// implementation of OnCtlColor for default gray backgrounds
//   (works for any interaction_impl containing controls)
//  return value of FALSE means caller must call DefWindowProc's default
//  TRUE means that 'hbrGray' will be used and the appropriate text
//    ('clrText') and background colors are set.
   bool interaction_impl::GrayCtlColor(HDC hDC, oswindow oswindow, UINT nCtlColor, HBRUSH hbrGray, COLORREF clrText)
   {
      if (hDC == nullptr)
      {
         // sometimes Win32 passes a nullptr hDC in the WM_CTLCOLOR message.
         //         information(trace_category_appmsg, trace_level_warning, "Warning: hDC is nullptr in interaction_impl::GrayCtlColor; WM_CTLCOLOR not processed.\n");
         return FALSE;
      }

      if (hbrGray == nullptr ||
            nCtlColor == CTLCOLOR_EDIT || nCtlColor == CTLCOLOR_MSGBOX ||
            nCtlColor == CTLCOLOR_SCROLLBAR)
      {
         return FALSE;
      }

      if (nCtlColor == CTLCOLOR_LISTBOX)
      {
         // only handle requests to draw the space between edit and drop button
         //  in a drop-down combo (not a drop-down list)
         if (!__is_combo_box_control(oswindow, (UINT)CBS_DROPDOWN))
            return FALSE;
      }

      // set background color and return handle to brush
      LOGBRUSH logbrush;
      VERIFY(::GetObject(hbrGray, sizeof(LOGBRUSH), (LPVOID)&logbrush));
      ::SetBkColor(hDC, logbrush.lbColor);
      if (clrText == (COLORREF)-1)
         clrText = Session.get_default_color(COLOR_WINDOWTEXT);  // normal text
      ::SetTextColor(hDC, clrText);
      return TRUE;
   }


   void interaction_impl::CenterWindow(::user::interaction * pAlternateOwner)
   {
      //ASSERT(::is_window(get_handle()));

      //// determine owner interaction_impl to center against
      //u32 uStyle = GetStyle();
      //__pointer(::user::interaction) oswindow_Center = pAlternateOwner;
      //if(pAlternateOwner == nullptr)
      //{
      //   if(uStyle & WS_CHILD)
      //      oswindow_Center = GetParent();
      //   else
      //      oswindow_Center = GetWindow(GW_OWNER);
      //   if(oswindow_Center != nullptr)
      //   {
      //      // let parent determine alternate center interaction_impl
      //      __pointer(::user::interaction) oswindow_Temp((lparam)oswindow_Center->send_message(WM_QUERYCENTERWND));

      //      if(oswindow_Temp != nullptr)
      //         oswindow_Center = oswindow_Temp;
      //   }
      //}

      //// get coordinates of the interaction_impl relative to its parent
      //rect rcDlg;
      //window_rectangle(&rcDlg);
      //rect rcArea;
      //rect rcCenter;
      //__pointer(::user::interaction) oswindow_Parent;
      //if(!(uStyle & WS_CHILD))
      //{
      //   // don't center against invisible or minimized windows
      //   if(oswindow_Center != nullptr)
      //   {
      //      u32 dwAlternateStyle = oswindow_Center->get_window_long(GWL_STYLE);
      //      if(!(dwAlternateStyle & WS_VISIBLE) || (dwAlternateStyle & WS_MINIMIZE))
      //         oswindow_Center = nullptr;
      //   }

      //   /*
      //   MONITORINFO mi;
      //   mi.cbSize = sizeof(mi);

      //   // center within appropriate monitor coordinates
      //   if(oswindow_Center == nullptr)
      //   {

      //   :: GetMonitorInfo(::MonitorFromWindow(hwDefault,MONITOR_DEFAULTTOPRIMARY),&mi);
      //   rcCenter = mi.rcWork;
      //   rcArea = mi.rcWork;
      //   }
      //   else
      //   {
      //   oswindow_Center->window_rectangle(&rcCenter);
      //   ::GetMonitorInfo(::MonitorFromWindow(oswindow_Center->get_handle(),MONITOR_DEFAULTTONEAREST),&mi);
      //   rcArea = mi.rcWork;
      //   }
      //   */
      //}
      //else
      //{
      //   // center within parent client coordinates
      //   oswindow_Parent = GetParent();
      //   ASSERT(oswindow_Parent->is_window());

      //   oswindow_Parent->client_rectangle(&rcArea);
      //   ASSERT(oswindow_Center->is_window());
      //   oswindow_Center->client_rectangle(&rcCenter);
      //   ::MapWindowPoints(oswindow_Center->get_handle(),oswindow_Parent->get_handle(),(const point &*)&rcCenter,2);
      //}

      //// find dialog's upper left based on rcCenter
      //i32 xLeft = (rcCenter.left + rcCenter.right) / 2 - rcDlg.width() / 2;
      //i32 yTop = (rcCenter.top + rcCenter.bottom) / 2 - rcDlg.height() / 2;

      //// if the dialog is outside the screen, move it inside
      //if(xLeft < rcArea.left)
      //   xLeft = rcArea.left;
      //else if(xLeft + rcDlg.width() > rcArea.right)
      //   xLeft = rcArea.right - rcDlg.width();

      //if(yTop < rcArea.top)
      //   yTop = rcArea.top;
      //else if(yTop + rcDlg.height() > rcArea.bottom)
      //   yTop = rcArea.bottom - rcDlg.height();

      //// map screen coordinates to child coordinates
      //set_window_pos(0,xLeft,yTop,-1,-1,
      //             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
   }

   bool interaction_impl::CheckAutoCenter()
   {
      return TRUE;
   }

/////////////////////////////////////////////////////////////////////////////
// Dialog initialization support

   bool interaction_impl::ExecuteDlgInit(const char * pszResourceName)

   {
      // find resource handle
      LPVOID pResource = nullptr;

      HGLOBAL hResource = nullptr;
      if (pszResourceName != nullptr)

      {
         //         HINSTANCE hInst = ::aura::FindResourceHandle(pszResourceName, RT_DLGINIT);

         //       HRSRC hDlgInit = ::FindResource(hInst, pszResourceName, RT_DLGINIT);

         /*     if (hDlgInit != nullptr)
         {
         // load it
         hResource = LoadResource(hInst, hDlgInit);
         if (hResource == nullptr)
         return FALSE;
         // lock it
         pResource = LockResource(hResource);

         ASSERT(pResource != nullptr);

         }*/
      }

      // execute it
      bool bResult = ExecuteDlgInit(pResource);


      // cleanup
      if (pResource != nullptr && hResource != nullptr)

      {
         UnlockResource(hResource);
         FreeResource(hResource);
      }
      return bResult;
   }

   bool interaction_impl::ExecuteDlgInit(LPVOID pResource)

   {
      bool bSuccess = TRUE;
      if (pResource != nullptr)

      {
         UNALIGNED WORD* pnRes = (WORD*)pResource;

         while (bSuccess && *pnRes != 0)

         {
            WORD nIDC = *pnRes++;

            WORD nMsg = *pnRes++;

            DWORD dwLen = *((UNALIGNED DWORD*&)pnRes)++;


            // In Win32 the WM_ messages have changed.  They have
            // to be translated from the 32-bit values to 16-bit
            // values here.

#define WIN16_LB_ADDSTRING  0x0401
#define WIN16_CB_ADDSTRING  0x0403
#define __CB_ADDSTRING   0x1234

            // unfortunately, WIN16_CB_ADDSTRING == CBEM_INSERTITEM
            if (nMsg == __CB_ADDSTRING)
               nMsg = CBEM_INSERTITEM;
            else if (nMsg == WIN16_LB_ADDSTRING)
               nMsg = LB_ADDSTRING;
            else if (nMsg == WIN16_CB_ADDSTRING)
               nMsg = CB_ADDSTRING;

            // check for invalid/unknown message types
            ASSERT(nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING ||
                   nMsg == CBEM_INSERTITEM);

#ifdef DEBUG
            // For AddStrings, the ::count must exactly delimit the
            // string, including the nullptr termination.  This check
            // will not catch all mal-formed ADDSTRINGs, but will
            // catch some.
            if (nMsg == LB_ADDSTRING || nMsg == CB_ADDSTRING || nMsg == CBEM_INSERTITEM)
               ASSERT(*((byte *)pnRes + (UINT)dwLen - 1) == 0);

#endif

            if (nMsg == CBEM_INSERTITEM)
            {
               COMBOBOXEXITEM item = { 0 };
               item.mask = CBEIF_TEXT;
               item.iItem = -1;
               string strText(reinterpret_cast<char *>(pnRes));

               item.pszText = const_cast<char *>(strText.GetString());
               if (::SendDlgItemMessage(get_handle(), nIDC, nMsg, 0, (LPARAM)&item) == -1)
                  bSuccess = FALSE;
            }
            {
               // List/Combobox returns -1 for error
               if (::SendDlgItemMessageA(get_handle(), nIDC, nMsg, 0, (LPARAM)pnRes) == -1)

                  bSuccess = FALSE;
            }


            // skip past data
            pnRes = (WORD*)((byte *)pnRes + (UINT)dwLen);

         }
      }

      // send update message to all controls after all other siblings loaded
      if (bSuccess)
         send_message_to_descendants(WM_INITIALUPDATE, 0, 0, FALSE, FALSE);

      return bSuccess;
   }


   //::point interaction_impl::_client_parent_top_left()
   //{

   //   if(!(GetStyle() & WS_CHILD))
   //   { 
   //   
   //      return _client_screen_top_left();
   //   
   //   }

   //   HWND hwndParent = ::GetParent(m_oswindow);

   //   if (hwndParent == NULL)
   //   {

   //      return _client_screen_top_left();

   //   }

   //   ::point point;

   //   ClientToScreen(m_oswindow, point);

   //   ScreenToClient(hwndParent, point);

   //   return point;

   //}


   //::point interaction_impl::_client_screen_top_left()
   //{

   //   ::point point;

   //   ClientToScreen(m_oswindow, point);

   //   return point;

   //}


   void interaction_impl::UpdateDialogControls(channel* pTarget, bool bDisableIfNoHndler)
   {
      UNREFERENCED_PARAMETER(pTarget);
      UNREFERENCED_PARAMETER(bDisableIfNoHndler);
      ::user::command state(m_pobject);
      interaction_impl wndTemp;       // very temporary interaction_impl just for CmdUI update


   }


   bool interaction_impl::ContinueModal()
   {

      if (m_puserinteraction == nullptr)
      {

         return false;

      }

      return m_puserinteraction->ContinueModal();

      //return iLevel < m_puserinteraction->m_iModalCount;

   }


   void interaction_impl::EndModalLoop(id nResult)
   {

      ASSERT(::is_window(get_handle()));

      m_puserinteraction->EndModalLoop(nResult);
      //// this result will be returned from interaction_impl::RunModalLoop
      //m_puserinteraction->m_nModalResult = (i32)nResult;

      //// make sure a message goes through to exit the modal loop
      //if (m_puserinteraction->m_iModalCount > 0)
      //{

      //   m_puserinteraction->m_iModalCount--;

      //   for (index i = 0; i < m_puserinteraction->m_threadptraModal.get_count(); i++)
      //   {

      //      m_puserinteraction->m_threadptraModal[i]->kick_thread();

      //   }

      //   m_puserinteraction->kick_queue();

      //   get_thread()->kick_thread();

      //}

   }


//void interaction_impl::EndAllModalLoops(id nResult)
//{

//   ASSERT(::is_window(get_handle()));

//   // this result will be returned from interaction_impl::RunModalLoop
//   m_puserinteraction->m_idModalResult = nResult;

//   // make sure a message goes through to exit the modal loop
//   if (m_puserinteraction->m_iModalCount > 0)
//   {

//      i32 iLevel = m_puserinteraction->m_iModalCount - 1;

//      m_puserinteraction->m_iModalCount = 0;

//      m_puserinteraction->kick_queue();

//      get_thread()->kick_thread();

//      for (i32 i = iLevel; i >= 0; i--)
//      {

//         ::thread * pthread = prop(string("RunModalLoop.thread(") + __str(i) + ")").cast < ::thread >();

//         try
//         {

//            pthread->kick_thread();

//         }
//         catch (...)
//         {

//         }

//      }

//   }

//}


   bool interaction_impl::subclass_window(oswindow oswindow)
   {

      if (!attach(oswindow))
         return FALSE;

      // allow any other subclassing to occur
      pre_subclass_window();

      m_pfnSuper = (WNDPROC)::GetWindowLongPtr(oswindow, GWLP_WNDPROC);

      // now hook into the AFX WndProc
      WNDPROC* plpfn = GetSuperWndProcAddr();

      WNDPROC oldWndProc = (WNDPROC)::SetWindowLongPtr(oswindow, GWLP_WNDPROC, (iptr)__get_window_procedure());
      ASSERT(oldWndProc != __get_window_procedure());

      if (*plpfn == nullptr)

         *plpfn = oldWndProc;   // the first control of that type created

#ifdef DEBUG
      else if (*plpfn != oldWndProc)

      {

         information(trace_level_warning, "point: Trying to use subclass_window with incorrect interaction_impl\n");
         information(trace_level_warning, "\tderived class.\n");
         information(trace_level_warning, "\toswindow_ = $%08X (nIDC=$%08X) is not a %hs.\n", (UINT)(uptr)oswindow, __get_dialog_control_id(oswindow), typeid(*this).name());

         ASSERT(FALSE);

         // undo the subclassing if continuing after assert

         ::SetWindowLongPtr(oswindow, GWLP_WNDPROC, (iptr)oldWndProc);

      }
#endif

      message::size size(m_pobject);

      _001OnSize(&size);

      return true;

   }


   bool interaction_impl::SubclassDlgItem(UINT nID, ::window_sp pParent)
   {

      ASSERT(pParent);

      ASSERT(::is_window((pParent)->get_handle()));

      // check for normal dialog control first
      oswindow oswindow_Control = ::GetDlgItem((pParent)->get_handle(), nID);
      if (oswindow_Control != nullptr)
         return subclass_window(oswindow_Control);


      return false;   // control not found
   }


   oswindow interaction_impl::unsubclass_window()
   {
      //ASSERT(::is_window(get_handle()));

      if (!_is_window())
         return nullptr;

      // set WNDPROC back to original value
      WNDPROC* plpfn = GetSuperWndProcAddr();

      ::SetWindowLongPtr(get_handle(), GWLP_WNDPROC, (iptr)*plpfn);

      *plpfn = nullptr;


      // and detach the oswindow from the interaction_impl object
      return detach();
   }


   /*

   bool interaction_impl::IsChild(const ::user::interaction * pwindow) const
   {

   ASSERT(::is_window(get_handle()));

   if(pwindow->get_handle() == nullptr)
   {
   return ::user::primitive::IsChild(pwindow);
   }
   else
   {
   return ::IsChild(get_handle(),pwindow->get_handle()) != FALSE;
   }

   }

   */


   bool interaction_impl::_is_window() const
   {

      if (!m_bUserPrimitiveOk)
      {

         return false;

      }

      if (m_puserinteraction == nullptr)
      {

         return false;

      }

      if (!::is_window(get_handle()))
      {

         return false;

      }

      return true;

   }


   void interaction_impl::on_layout(::draw2d::graphics_pointer & pgraphics)
   {


   }

   
   void interaction_impl::rects_from_os()
   {

      ::rectangle_i32 rectClient;

      ::GetClientRect(m_oswindow, rectClient);

      ::rectangle_i32 rectScreen;

      ::GetWindowRect(m_oswindow, rectScreen);

      m_puserinteraction->m_pointScreen = rectScreen.origin();

      m_puserinteraction->m_size = rectScreen.size();

      if (rectClient.size() != m_puserinteraction->m_size)
      {

         informationf("ATTENTION!! Client Size <> Window Size");

      }


      //m_puserinteraction->m_sizeScreen = rectScreen.size();

      //m_puserinteraction->m_pointScreenClient.x = 0;

      //m_puserinteraction->m_pointScreenClient.y = 0;

      //::ScreenToClient(m_oswindow, m_puserinteraction->m_pointScreenClient);

      //HWND hwndParent = ::GetParent(m_oswindow);

      //if (hwndParent != NULL)
      //{

      //   m_puserinteraction->m_pointParentClient.x = 0;

      //   m_puserinteraction->m_pointParentClient.y = 0;

      //   ::ClientToScreen(m_oswindow, m_puserinteraction->m_pointParentClient);

      //   ::ScreenToClient(hwndParent, m_puserinteraction->m_pointParentClient);

      //}
      //else
      //{

      //   m_puserinteraction->m_pointParentClient = m_puserinteraction.m_pointScreenWindow;

      //}

      //m_puserinteraction->m_pointClient = m_puserinteraction.m_pointScreenWindow;

      //m_puserinteraction->m_pointClient -= m_puserinteraction.m_pointScreenClient;

   }


   //pointd interaction_impl::client_screen_top_left()
   //{

   //   ::point point;

   //   ::ClientToScreen(m_oswindow, &point);

   //   return pointd(point.x, point.y);

   //}


   bool interaction_impl::window_rect_from_os(RECT * prect)
   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      ::rectangle_i32 rectWindow;

      //if (!(GetExStyle() & WS_EX_LAYERED))
      //{

      //   ::GetWindowRect(m_oswindow, rectWindow);

      //   m_puserinteraction->m_pointParentClientRequest = rectWindow.origin();

      //   m_puserinteraction->m_sizeClientRequest = rectWindow.size();

      //}
      //else
      //{

      //   ::set_rect_point_size(&rectWindow, m_puserinteraction->m_pointParentClientRequest, m_puserinteraction.m_sizeClientRequest);

      //}

      //*prect = rectWindow;

      //if (GetParent() != nullptr)
      //{

      //   GetParent()->client_to_screen(prect);

      //}

      return true;

   }


   bool interaction_impl::client_rect_from_os(RECT * prect)
   {

      //oswindow handle = get_handle();

      //if (!::is_window(get_handle()))
      //{

      //   return false;

      //}

      //::rectangle_i32 rect32;

      //if (!(GetExStyle() & WS_EX_LAYERED))
      //{

      //   if (!::GetWindowRect(get_handle(), rect32))
      //   {

      //      return false;

      //   }

      //   if (GetParent() != nullptr)
      //   {

      //      GetParent()->screen_to_client(rect32);

      //   }

      //   //::copy(m_puserinteraction->m_rectParentClient, rect32);

      //}

      //rect32 = m_puserinteraction->m_rectParentClient;

      //rect32.offset(-rect32.top_left());

      //::copy(prect, rect32);

      return true;

   }


   void interaction_impl::_001WindowMinimize(bool bNoActivate)
   {

      primitive_impl::_001WindowMinimize(bNoActivate);

   }


   void interaction_impl::_001WindowMaximize()
   {

      primitive_impl::_001WindowMaximize();

   }


   void interaction_impl::_001WindowFullScreen(const ::rectangle_i32 & rectHint)
   {

      primitive_impl::_001WindowFullScreen(rectHint);

   }


   void interaction_impl::_001WindowRestore()
   {

      primitive_impl::_001WindowRestore();

   }


   bool interaction_impl::display(::e_display edisplay)
   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      return true;

   }


   bool interaction_impl::window_is_iconic()
   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      if (GetExStyle() & WS_EX_LAYERED)
      {

         return m_puserinteraction->m_edisplay == ::display_iconic;

      }
      else
      {

         return ::IsIconic(get_handle()) != FALSE;

      }

   }


   bool interaction_impl::window_is_zoomed()
   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      return m_puserinteraction->get_display() == ::display_zoomed;

   }


   ::user::interaction * interaction_impl::GetParent() const
   {

      if (!::is_window(get_handle()))
         return nullptr;

      if (get_handle() == nullptr)
         return nullptr;

      HWND hwndParent = ::GetParent(get_handle());

      if (hwndParent == nullptr)
         return nullptr;

      return System.ui_from_handle(hwndParent);

   }


   ::user::interaction * interaction_impl::SetParent(::user::interaction * pWndNewParent)
   {

      ASSERT(::is_window(get_handle()));

      return System.ui_from_handle(::SetParent(get_handle(), pWndNewParent->get_handle()));

   }

   ::user::interaction * interaction_impl::GetOwner() const
   {

      if (!::is_window(get_handle()))
         return nullptr;

      if (get_handle() == nullptr)
         return nullptr;

      HWND hwndParent = ::GetWindow(get_handle(), GW_OWNER);

      if (hwndParent == nullptr)
         return GetParent();

      return System.ui_from_handle(hwndParent);
   }

   ::user::interaction * interaction_impl::SetOwner(::user::interaction * pWndNewParent)
   {

      return nullptr;

   }



   LONG interaction_impl::get_window_long(i32 nIndex) const
   {
      return ::GetWindowLong(get_handle(), nIndex);
   }

   LONG interaction_impl::set_window_long(i32 nIndex, LONG lValue)
   {
      return ::SetWindowLong(get_handle(), nIndex, lValue);
   }

   LONG_PTR interaction_impl::get_window_long_ptr(i32 nIndex) const
   {
      return ::GetWindowLongPtr(get_handle(), nIndex);
   }


   LONG_PTR interaction_impl::set_window_long_ptr(i32 nIndex, LONG_PTR lValue)
   {

      return ::SetWindowLongPtr(get_handle(), nIndex, lValue);

   }




// interaction_impl
   /* interaction_impl::operator oswindow() const
   { return this == nullptr ? nullptr : get_handle(); }*/
   bool interaction_impl::operator==(const interaction_impl& wnd) const
   {

      return (((interaction_impl *)&wnd)->get_handle()) == ((interaction_impl *)this)->get_handle();

   }


   bool interaction_impl::operator!=(const interaction_impl& wnd) const
   {

      return (((interaction_impl *)&wnd)->get_handle()) != ((interaction_impl *)this)->get_handle();

   }


   u32 interaction_impl::GetStyle() const
   {

      if (!::is_window(get_handle()))
         return 0;

      return (u32)::GetWindowLong(get_handle(), GWL_STYLE);

   }


   u32 interaction_impl::GetExStyle() const
   {

      if (!::is_window(get_handle()))
         return 0;

      return (u32)::GetWindowLong(get_handle(), GWL_EXSTYLE);

   }


   bool interaction_impl::ModifyStyle(u32 dwRemove, u32 dwAdd, UINT nFlags)
   {

      if (!::is_window(get_handle()))
         return false;

      return ModifyStyle(get_handle(), dwRemove, dwAdd, nFlags);

   }


   bool interaction_impl::ModifyStyleEx(u32 dwRemove, u32 dwAdd, UINT nFlags)
   {

      if (!::is_window(get_handle()))
         return false;

      return ModifyStyleEx(get_handle(), dwRemove, dwAdd, nFlags);

   }


   LRESULT interaction_impl::send_message(const ::id & id, WPARAM wParam, lparam lParam)

   {
      //ASSERT(::is_window(get_handle()));
      return ::SendMessage(get_handle(), message, wParam, lParam);

   }


   bool interaction_impl::post_message(const ::id & id, WPARAM wParam, lparam lParam)

   {

      return ::PostMessage(get_handle(), message, wParam, lParam) != FALSE;

   }


   bool interaction_impl::DragDetect(const ::point & point) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return ::DragDetect(((interaction_impl *)this)->get_handle(), point) != FALSE;

   }

   void interaction_impl::set_window_text(const char * pszString)

   {

      DWORD_PTR lresult = 0;

      m_puserinteraction->m_strWindowText = pszString;


      wstring wstrText(m_puserinteraction->m_strWindowText);

      const unichar * pwszText = wstrText;

      if (!::SendMessageTimeoutW(get_handle(), WM_SETTEXT, 0, (LPARAM)pwszText, SMTO_ABORTIFHUNG, 500, &lresult))
         return;

   }

   strsize interaction_impl::get_window_text(char * pszString, strsize nMaxCount)

   {

      string str;

      get_window_text(str);

      strncpy_dup(pszString, str, (size_t) min(nMaxCount, str.get_length()));


      return str.get_length();

   }

   void interaction_impl::get_window_text(string & str)
   {

      DWORD_PTR lresult = 0;

      if (!::SendMessageTimeoutW(get_handle(), WM_GETTEXTLENGTH, 0, 0, SMTO_ABORTIFHUNG, 84, &lresult))
         return;

      wstring wstr;

      if (!::SendMessageTimeoutW(get_handle(), WM_GETTEXT, (LPARAM)wstr.alloc(lresult + 1), lresult + 1, SMTO_ABORTIFHUNG, 84, &lresult))
         return;

      str = wstr;

   }

   strsize interaction_impl::get_window_text_length()
   {

      ASSERT(::is_window(get_handle()));

      return ::GetWindowTextLength(get_handle());

   }


   void interaction_impl::DragAcceptFiles(bool bAccept)
   {
      ASSERT(::is_window(get_handle()));
      ::DragAcceptFiles(get_handle(), bAccept);
   }


   UINT interaction_impl::ArrangeIconicWindows()
   {

      ASSERT(::is_window(get_handle()));
      return ::ArrangeIconicWindows(get_handle());

   }


//i32 interaction_impl::SetWindowRgn(HRGN hRgn,bool bRedraw)
//{

//   //ASSERT(::is_window(get_handle())); return ::SetWindowRgn(get_handle(),hRgn,bRedraw);

//}


//i32 interaction_impl::GetWindowRgn(HRGN hRgn)
//{

//   //ASSERT(::is_window(get_handle()) && hRgn != nullptr); return ::GetWindowRgn(get_handle(),hRgn);

//}


   //void interaction_impl::bring_to_top(::e_display edisplay)
   //{

   //   if (GetParent() == nullptr)
   //   {

   //      // place the interaction_impl on top except for certain nCmdShow

   //      if (is_visible(edisplay) 
   //         && edisplay_command(edisplay) != display_iconic &&
   //         !no_activate(edisplay))
   //      {

   //         oswindow oswindow = get_handle();

   //         oswindow = ::GetLastActivePopup(oswindow);

   //         ::user::interaction * puserinteraction = System.ui_from_handle(oswindow);

   //         if (puserinteraction == nullptr)
   //            BringWindowToTop();
   //         else
   //            puserinteraction->BringWindowToTop();

   //      }

   //   }

   //}

   // MSDN
   // Brings the specified window to the top of the Z order.
   // If the window is a top-level window, it is activated. 
   // If the window is a child window, the top-level parent 
   // window associated with the child window is activated.
   //
   // Use the BringWindowToTop function to uncover any window
   // that is partially or completely obscured by other windows.
   // Calling this function is similar to calling the set_window_pos 
   // function to change a window's position in the Z order.
   // BringWindowToTop does not make a window a top-level window.

   //bool interaction_impl::BringWindowToTop()
   //{

   //   bool bOk = ::BringWindowToTop(get_handle()) != FALSE;


   //   if (GetExStyle() & WS_EX_LAYERED)
   //   {

   //      if (!(GetExStyle() & WS_EX_TOPMOST))
   //      {

   //         ::set_window_pos(get_handle(), (HWND)zorder_top, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

   //         //::set_window_pos(get_handle(),(HWND)zorder_top,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

   //         //::set_window_pos(get_handle(),(HWND)zorder_top_most,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

   //         //::set_window_pos(get_handle(),(HWND)zorder_top,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

   //      }

   //   }

   //   return bOk;

   //}

   void interaction_impl::MapWindowPoints(::window_sp pwndTo, LPPOINT pPoint, UINT nCount)

   {
      ASSERT(::is_window(get_handle()));
      ::MapWindowPoints(get_handle(), pwndTo->get_handle(), pPoint, nCount);

   }

   void interaction_impl::MapWindowPoints(::window_sp pwndTo, RECT * prect)

   {
      ASSERT(::is_window(get_handle()));
      ::MapWindowPoints(get_handle(), pwndTo->get_handle(), (LPPOINT)prect, 2);

   }



   void interaction_impl::UpdateWindow()
   {
      ::UpdateWindow(get_handle());
   }

   void interaction_impl::SetRedraw(bool bRedraw)
   {
      ASSERT(::is_window(get_handle()));
      ::SendMessage(get_handle(), WM_SETREDRAW, bRedraw, 0);
   }

   bool interaction_impl::GetUpdateRect(RECT * prect, bool bErase)

   {
      ASSERT(::is_window(get_handle()));
      return ::GetUpdateRect(get_handle(), prect, bErase) != FALSE;

   }

   i32 interaction_impl::GetUpdateRgn(::draw2d::region* pRgn, bool bErase)
   {
      ASSERT(::is_window(get_handle()));
      return ::GetUpdateRgn(get_handle(), (HRGN)pRgn->get_os_data(), bErase);
   }

   void interaction_impl::Invalidate(bool bErase)
   {
      ASSERT(::is_window(get_handle()));
      ::InvalidateRect(get_handle(), nullptr, bErase);
   }

   void interaction_impl::InvalidateRect(LPCRECT rect, bool bErase)

   {
      ASSERT(::is_window(get_handle()));
      ::InvalidateRect(get_handle(), rect, bErase);

   }

   void interaction_impl::InvalidateRgn(::draw2d::region* pRgn, bool bErase)
   {
      ASSERT(::is_window(get_handle()));
      ::InvalidateRgn(get_handle(), (HRGN)pRgn->get_os_data(), bErase);
   }

   void interaction_impl::ValidateRect(LPCRECT rect)

   {

      ASSERT(::is_window(get_handle()));

      ::ValidateRect(get_handle(), rect);


   }


   void interaction_impl::ValidateRgn(::draw2d::region* pRgn)
   {

      ASSERT(::is_window(get_handle()));

      ::ValidateRgn(get_handle(), (HRGN)pRgn->get_os_data());

   }


   void interaction_impl::on_visual_applied()
   {

      rects_from_os();

      ::user::interaction_impl::on_visual_applied();

   }


   void interaction_impl::_001ApplyVisual()
   {

      return ::user::interaction_impl::_001ApplyVisual();

   }


   bool interaction_impl::_is_window_visible()
   {

      try
      {

         if (!::IsWindowVisible(get_handle()))
         {

            return false;

         }

         return true;

      }
      catch (...)
      {

         return false;

      }

   }


   void interaction_impl::ShowOwnedPopups(bool bShow)
   {

      ASSERT(::is_window(get_handle()));

      ::ShowOwnedPopups(get_handle(), bShow);

   }




   ::draw2d::graphics * interaction_impl::GetDCEx(::draw2d::region* prgnClip, u32 flags)
   {

      ASSERT(::is_window(get_handle()));

      ::draw2d::graphics_sp g(e_create_new, this);

      g->attach(::GetDCEx(get_handle(), (HRGN)prgnClip->get_os_data(), flags));

      return g.detach();


   }


   bool interaction_impl::LockWindowUpdate()
   {

      ASSERT(::is_window(get_handle()));

      return ::LockWindowUpdate(get_handle()) != FALSE;

   }

   void interaction_impl::UnlockWindowUpdate()
   {

      ASSERT(::is_window(get_handle()));

      ::LockWindowUpdate(nullptr);

   }


   bool interaction_impl::RedrawWindow(const ::rectangle_i32& rectUpdate, ::draw2d::region* prgnUpdate, UINT flags)
   {

      if (m_bDestroyImplOnly)
      {

         return false;

      }

      if (!m_puserinteraction->is_window_visible())
      {

         return true;

      }

      if (!(GetExStyle() & WS_EX_LAYERED))
      {

         ::RedrawWindow(get_handle(), nullptr, nullptr, flags);

      }

      if (flags & RDW_UPDATENOW)
      {





         //if (GetExStyle() & WS_EX_LAYERED)
         {

            _001UpdateWindow();

            return true;

         }
         //else
         //{

         //   if (!is_window_visible() && !m_bShowFlags)
         //      return false;

         //   if (!is_window_visible())
         //   {

         //      if (m_iShowFlags & SWP_SHOWWINDOW)
         //      {

         //         display(display_normal);

         //      }

         //   }

         //   return ::set_need_redraw(get_handle(), pRectUpdate, prgnUpdate == nullptr ? nullptr : (HRGN)prgnUpdate->get_os_data(),

         //      flags | RDW_NOERASE | RDW_NOFRAME | RDW_INVALIDATE) != FALSE;

         //}

      }
      else
      {

         m_puserinteraction->m_bRedraw = true;

      }

      return true;

   }





   bool interaction_impl::EnableScrollBar(i32 nSBFlags, UINT nArrowFlags)
   {

      ASSERT(::is_window(get_handle()));

      return ::EnableScrollBar(get_handle(), nSBFlags, nArrowFlags) != FALSE;

   }

   //bool interaction_impl::DrawAnimatedRects(i32 idAni, CONST LPRECTprcFrom, CONST LPRECTlprcTo)

   //{

   //   ASSERT(::is_window(get_handle()));

   //   return ::DrawAnimatedRects(get_handle(), idAni, prcFrom, lprcTo) != FALSE;


   //}

   bool interaction_impl::DrawCaption(::draw2d::graphics_pointer & pgraphics, const rect & prc, UINT uFlags)

   {

      ASSERT(::is_window(get_handle()));

      ::exception::throw_not_implemented();
      return false;
      //      return ::DrawCaption(get_handle(), (HDC)(dynamic_cast<::windows::graphics * >(pgraphics))->get_handle(), prc, uFlags) != FALSE;


   }


   bool interaction_impl::is_window_enabled()
   {

      if (!::is_window(get_handle()))
         return false;

      return ::IsWindowEnabled(get_handle()) != FALSE;

   }


   bool interaction_impl::enable_window(bool bEnable)
   {

      ASSERT(::is_window(get_handle()));

      return ::EnableWindow(get_handle(), bEnable) != FALSE;

   }

   ::user::interaction * interaction_impl::GetActiveWindow()
   {

      return System.ui_from_handle(::GetActiveWindow());

   }


   ::user::interaction * interaction_impl::SetActiveWindow()
   {

      if (!::is_window(get_handle()))
      {

         return nullptr;

      }

      if (!::IsWindowVisible(get_handle()))
      {

         return nullptr;

      }

      oswindow window = ::SetActiveWindow(get_handle());

      ::user::interaction * puserinteraction = System.ui_from_handle(window);

      return puserinteraction;

   }



   ::user::interaction * interaction_impl::GetFocus()
   {

      return System.ui_from_handle(::GetFocus());

   }


   bool interaction_impl::has_focus()
   {

      HWND hwndFocus = ::get_focus();

      HWND hwndThis = get_handle();

      return hwndFocus ==  hwndThis;

   }


   bool interaction_impl::is_active()
   {

      oswindow oswindowActive = ::GetActiveWindow();

      return  oswindowActive == m_oswindow;

   }


   bool interaction_impl::SetFocus()
   {

      if (!::is_window(get_handle()))
      {

         return false;

      }

      if (!::IsWindowVisible(get_handle()))
      {

         return false;

      }

      m_puserinteraction->post_pred([this]()
      {

         HWND hwnd = ::SetFocus(get_handle());

         ::output_debug_string("::windows::interaction_impl::SetFocus ::SetFocus(" + ::hex::lower_from((iptr) hwnd) + ")");

         return success;

      });

      return true;

   }


   ::user::interaction *  interaction_impl::get_desktop_window()
   {

      return System.ui_from_handle(::get_desktop_window());

   }


// Helper for radio buttons
   i32 interaction_impl::GetCheckedRadioButton(i32 nIDFirstButton, i32 nIDLastButton)
   {
      for (i32 nID = nIDFirstButton; nID <= nIDLastButton; nID++)
      {
         if (IsDlgButtonChecked(nID))
            return nID; // id that matched
      }
      return 0; // invalid ID
   }


   void interaction_impl::CheckDlgButton(i32 nIDButton, UINT nCheck)
   {

      ASSERT(::is_window(get_handle()));

      ::CheckDlgButton(get_handle(), nIDButton, nCheck);

   }


   void interaction_impl::CheckRadioButton(i32 nIDFirstButton, i32 nIDLastButton, i32 nIDCheckButton)
   {

      ASSERT(::is_window(get_handle()));

      ::CheckRadioButton(get_handle(), nIDFirstButton, nIDLastButton, nIDCheckButton);

   }


   i32 interaction_impl::DlgDirList(char * pPathSpec, i32 nIDListBox, i32 nIDStaticPath, UINT nFileType)

   {

      ASSERT(::is_window(get_handle()));

      return ::DlgDirList(get_handle(), pPathSpec, nIDListBox, nIDStaticPath, nFileType);


   }


   i32 interaction_impl::DlgDirListComboBox(char * pPathSpec, i32 nIDComboBox, i32 nIDStaticPath, UINT nFileType)

   {

      ASSERT(::is_window(get_handle()));

      return ::DlgDirListComboBox(get_handle(), pPathSpec, nIDComboBox, nIDStaticPath, nFileType);


   }


   bool interaction_impl::DlgDirSelect(char * pString, i32 nSize, i32 nIDListBox)

   {

      ASSERT(::is_window(get_handle()));

      return ::DlgDirSelectEx(get_handle(), pString, nSize, nIDListBox) != FALSE;


   }


   bool interaction_impl::DlgDirSelectComboBox(char * pString, i32 nSize, i32 nIDComboBox)

   {

      ASSERT(::is_window(get_handle()));

      return ::DlgDirSelectComboBoxEx(get_handle(), pString, nSize, nIDComboBox) != FALSE;


   }


   void interaction_impl::get_child_by_id(id id, oswindow* poswindow_) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      ASSERT(poswindow_ != nullptr);

      *poswindow_ = ::GetDlgItem(((interaction_impl *)this)->get_handle(), (i32)id);

   }


   UINT interaction_impl::GetChildByIdInt(i32 nID, BOOL * pTrans, bool bSigned) const

   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return ::GetDlgItemInt(((interaction_impl *)this)->get_handle(), nID, pTrans, bSigned);


   }


   i32 interaction_impl::GetChildByIdText(i32 nID, char * pStr, i32 nMaxCount) const

   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return ::GetDlgItemText(((interaction_impl *)this)->get_handle(), nID, pStr, nMaxCount);


   }


   ::window_sp interaction_impl::GetNextDlgGroupItem(::window_sp pWndCtl, bool bPrevious) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return System.ui_from_handle(::GetNextDlgGroupItem(((interaction_impl *)this)->get_handle(), pWndCtl->get_handle(), bPrevious));

   }


   ::window_sp interaction_impl::GetNextDlgTabItem(::window_sp pWndCtl, bool bPrevious) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return System.ui_from_handle(::GetNextDlgTabItem(((interaction_impl *)this)->get_handle(), pWndCtl->get_handle(), bPrevious));

   }


   UINT interaction_impl::IsDlgButtonChecked(i32 nIDButton) const
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      return ::IsDlgButtonChecked(((interaction_impl *)this)->get_handle(), nIDButton);
   }
   LPARAM interaction_impl::SendDlgItemMessage(i32 nID, const ::id & id, WPARAM wParam, LPARAM lParam)
   {
      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));
      return ::SendDlgItemMessage(((interaction_impl *)this)->get_handle(), nID, message, wParam, lParam);
   }
   void interaction_impl::SetDlgItemInt(i32 nID, UINT nValue, bool bSigned)
   {
      ASSERT(::is_window(get_handle()));
      ::SetDlgItemInt(get_handle(), nID, nValue, bSigned);
   }
   void interaction_impl::SetDlgItemText(i32 nID, const char * pszString)

   {
      ASSERT(::is_window(get_handle()));
      ::SetDlgItemText(get_handle(), nID, pszString);

   }
   i32 interaction_impl::ScrollWindowEx(i32 dx, i32 dy,
      LPCRECT pRectScroll, LPCRECT lpRectClip,

                                        ::draw2d::region* prgnUpdate, RECT * pRectUpdate, UINT flags)

   {
      ASSERT(::is_window(get_handle()));
      return ::ScrollWindowEx(get_handle(), dx, dy, pRectScroll, lpRectClip,

                              (HRGN)prgnUpdate->get_os_data(), pRectUpdate, flags);

   }

   void interaction_impl::ShowScrollBar(UINT nBar, bool bShow)
   {
      ASSERT(::is_window(get_handle()));
      ::ShowScrollBar(get_handle(), nBar, bShow);
   }
   ::user::interaction * interaction_impl::ChildWindowFromPoint(const ::point & point)
   {
      ASSERT(::is_window(get_handle()));

      return  System.ui_from_handle(::ChildWindowFromPoint(get_handle(), point));


   }

   ::user::interaction * interaction_impl::ChildWindowFromPoint(const ::point & point, UINT nFlags)
   {
      ASSERT(::is_window(get_handle()));

      return  System.ui_from_handle(::ChildWindowFromPointEx(get_handle(), point, nFlags));


   }



   ::user::interaction * interaction_impl::get_next_window(UINT nFlag)
   {

      if (!::is_window(get_handle()))
         return nullptr;

      return  System.ui_from_handle(::GetNextWindow(get_handle(), nFlag));

   }


   ::user::interaction * interaction_impl::GetTopWindow() const
   {

      ASSERT(::is_window(get_handle()));

      return System.ui_from_handle(::GetTopWindow(get_handle()));

   }


   ::user::interaction * interaction_impl::GetWindow(UINT nCmd) const
   {

      ASSERT(::is_window(get_handle()));

      return System.ui_from_handle(::GetWindow(get_handle(), nCmd));

   }


   ::user::interaction * interaction_impl::GetLastActivePopup() const
   {

      ASSERT(::is_window(get_handle()));

      return System.ui_from_handle(::GetLastActivePopup(get_handle()));

   }



   bool interaction_impl::FlashWindow(bool bInvert)
   {

      ASSERT(::is_window(get_handle()));

      return ::FlashWindow(get_handle(), bInvert) != FALSE;

   }

   bool interaction_impl::ChangeClipboardChain(oswindow oswindow_Next)
   {

      ASSERT(::is_window(get_handle()));

      return ::ChangeClipboardChain(get_handle(), oswindow_Next) != FALSE;

   }

   oswindow interaction_impl::SetClipboardViewer()
   {

      ASSERT(::is_window(get_handle()));

      return ::SetClipboardViewer(get_handle());

   }

   bool interaction_impl::OpenClipboard()
   {

      ASSERT(::is_window(get_handle()));

      return ::OpenClipboard(get_handle()) != FALSE;

   }

   ::window_sp interaction_impl::GetOpenClipboardWindow()
   {

      return System.ui_from_handle(::GetOpenClipboardWindow());

   }

   ::window_sp interaction_impl::GetClipboardOwner()
   {

      return System.ui_from_handle(::GetClipboardOwner());

   }

   ::window_sp interaction_impl::GetClipboardViewer()
   {

      return System.ui_from_handle(::GetClipboardViewer());

   }

   void interaction_impl::CreateCaret(::draw2d::bitmap* pBitmap)
   {

      ASSERT(::is_window(get_handle()));

      ::CreateCaret(get_handle(), (HBITMAP)pBitmap->get_os_data(), 0, 0);

   }

   void interaction_impl::CreateSolidCaret(i32 nWidth, i32 nHeight)
   {

      ASSERT(::is_window(get_handle()));

      ::CreateCaret(get_handle(), (HBITMAP)0, nWidth, nHeight);

   }

   void interaction_impl::CreateGrayCaret(i32 nWidth, i32 nHeight)
   {

      ASSERT(::is_window(get_handle()));

      ::CreateCaret(get_handle(), (HBITMAP)1, nWidth, nHeight);

   }

   
   point interaction_impl::GetCaretPos()
   {

      ::point point;

      ::GetCaretPos((LPPOINT)&point);

      return point;

   }


   void interaction_impl::SetCaretPos(const ::point & point)
   {

      ::SetCaretPos(point.x, point.y);

   }

   void interaction_impl::HideCaret()
   {

      ::HideCaret(get_handle());

   }

   void interaction_impl::ShowCaret()
   {

      ::ShowCaret(get_handle());

   }

   bool interaction_impl::SetForegroundWindow()
   {

      return ::SetForegroundWindow(get_handle()) != FALSE;

   }

   ::user::interaction * interaction_impl::GetForegroundWindow()
   {

      return System.ui_from_handle(::GetForegroundWindow());

   }

   bool interaction_impl::SendNotifyMessage(const ::id & id, WPARAM wParam, lparam lParam)

   {

      return ::SendNotifyMessage(get_handle(), message, wParam, lParam) != FALSE;

   }

// Win4
   HICON interaction_impl::SetIcon(HICON hIcon, bool bBigIcon)
   {

      return (HICON)send_message(WM_SETICON, bBigIcon, (LPARAM)hIcon);

   }

   HICON interaction_impl::GetIcon(bool bBigIcon) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return (HICON)const_cast <::windows::interaction_impl *> (this)->send_message(WM_GETICON, bBigIcon);

   }

   void interaction_impl::Print(::draw2d::graphics_pointer & pgraphics, u32 dwFlags) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      ::exception::throw_not_implemented();
      //      const_cast < ::windows::interaction_impl * > (this)->send_message(WM_PRINT, (WPARAM)(dynamic_cast<::windows::graphics * >(pgraphics))->get_handle(), (LPARAM) dwFlags);

   }

   void interaction_impl::PrintClient(::draw2d::graphics_pointer & pgraphics, u32 dwFlags) const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      ::exception::throw_not_implemented();
      //const_cast < ::windows::interaction_impl * > (this)->send_message(WM_PRINTCLIENT, (WPARAM)(dynamic_cast<::windows::graphics * >(pgraphics))->get_handle(), (LPARAM) dwFlags);

   }

   bool interaction_impl::SetWindowContextHelpId(u32 dwContextHelpId)
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return ::SetWindowContextHelpId(((interaction_impl *)this)->get_handle(), dwContextHelpId) != FALSE;

   }

   u32 interaction_impl::GetWindowContextHelpId() const
   {

      ASSERT(::is_window(((interaction_impl *)this)->get_handle()));

      return ::GetWindowContextHelpId(((interaction_impl *)this)->get_handle());

   }


// Default message map implementations
   void interaction_impl::OnActivateApp(bool, u32)
   {
      Default();
   }
   void interaction_impl::OnActivate(UINT, ::window_sp, bool)
   {
      Default();
   }
   void interaction_impl::OnCancelMode()
   {
      Default();
   }
   void interaction_impl::OnChildActivate()
   {
      Default();
   }
   void interaction_impl::OnClose()
   {
      Default();
   }
   void interaction_impl::OnContextMenu(::window_sp, point)
   {
      Default();
   }

   bool interaction_impl::OnCopyData(::window_sp, COPYDATASTRUCT*)
   {

      return Default() != FALSE;

   }

   void interaction_impl::OnEnable(bool)
   {
      Default();
   }
   void interaction_impl::OnEndSession(bool)
   {
      Default();
   }

   bool interaction_impl::OnEraseBkgnd(::draw2d::graphics *)
   {

      return Default() != FALSE;

   }

   void interaction_impl::OnGetMinMaxInfo(MINMAXINFO*)
   {
      Default();
   }
   void interaction_impl::OnIconEraseBkgnd(::draw2d::graphics *)
   {
      Default();
   }


   void interaction_impl::_001OnSetFocus(::message::message * pmessage)
   {

      m_bFocus = true;

      Default();

   }


   void interaction_impl::_001OnKillFocus(::message::message * pmessage)
   {

      m_bFocus = false;

   }


   LRESULT interaction_impl::OnMenuChar(UINT, UINT, ::user::menu*)
   {

      return Default();

   }


   void interaction_impl::OnMenuSelect(UINT, UINT, HMENU)
   {

      Default();

   }


   void interaction_impl::OnMove(i32, i32)
   {

      Default();

   }


   HCURSOR interaction_impl::OnQueryDragIcon()
   {

      return (HCURSOR)Default();

   }

   bool interaction_impl::OnQueryEndSession()
   {

      return Default() != FALSE;

   }

   bool interaction_impl::OnQueryNewPalette()
   {

      return Default() != FALSE;

   }

   bool interaction_impl::OnQueryOpen()
   {

      return Default() != FALSE;

   }

   void interaction_impl::_001OnSetCursor(::message::message * pmessage)
   {

      SCAST_PTR(::message::base, pbase, pmessage);

      auto pcursor = Session.get_cursor();

      if (pcursor != nullptr && pcursor->m_ecursor != cursor_system)
      {

         pcursor->set_current(m_puserinteraction, &Session);

      }

      pbase->set_lresult(1);

      pbase->m_bRet = true;

   }


   void interaction_impl::OnShowWindow(bool, UINT)
   {

      Default();

   }


   void interaction_impl::OnSize(UINT, i32, i32)
   {

      Default();

   }


   void interaction_impl::OnTCard(UINT, u32)
   {

      Default();

   }


   void interaction_impl::_001OnWindowPosChanging(::message::message * pmessage)
   {

      return;


   }


   void interaction_impl::_001OnWindowPosChanged(::message::message * pmessage)
   {

      output_debug_string("\ninteraction_impl::_001OnWindowPosChanged");

      if (::IsIconic(get_handle()))
      {

         if (!m_puserinteraction->window_is_iconic())
         {

            m_puserinteraction->defer_set_appearance(::display_iconic | edisplay_visual_flags(m_puserinteraction->m_edisplayRequest));

         }

      }
      else if (::IsZoomed(get_handle()))
      {

         if (!m_puserinteraction->window_is_zoomed())
         {

            m_puserinteraction->defer_set_appearance(::display_zoomed | edisplay_visual_flags(m_puserinteraction->m_edisplayRequest));

         }

      }

      return;


      //SCAST_PTR(::message::window_pos,pwindowpos,pmessage);

      //if(GetExStyle() & WS_EX_LAYERED)
      //{

      //   pwindowpos->m_bRet = true;

      //}

   }


   void interaction_impl::_001OnGetMinMaxInfo(::message::message * pmessage)
   {

      SCAST_PTR(::message::base, pbase, pmessage);

   }

   void interaction_impl::OnDropFiles(HDROP)
   {
      Default();
   }
   void interaction_impl::OnPaletteIsChanging(::window_sp)
   {
      Default();
   }

   bool interaction_impl::OnNcActivate(bool)
   {

      return Default() != FALSE;

   }

   void interaction_impl::OnNcCalcSize(bool, NCCALCSIZE_PARAMS*)
   {
      Default();
   }

   bool interaction_impl::OnNcCreate(::user::create_struct *)
   {

      return Default() != FALSE;

   }

   LRESULT interaction_impl::OnNcHitTest(const point & )
   {
      return Default();
   }
   void interaction_impl::OnNcLButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcLButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcLButtonUp(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcMButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcMButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcMButtonUp(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcMouseMove(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcPaint()
   {
      Default();
   }
   void interaction_impl::OnNcRButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcRButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnNcRButtonUp(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnSysChar(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnSysCommand(UINT, LPARAM)
   {
      Default();
   }
   void interaction_impl::OnSysDeadChar(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnSysKeyDown(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnSysKeyUp(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnCompacting(UINT)
   {
      Default();
   }
   void interaction_impl::OnFontChange()
   {
      Default();
   }
   void interaction_impl::OnPaletteChanged(::window_sp)
   {
      Default();
   }
   void interaction_impl::OnSpoolerStatus(UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnTimeChange()
   {
      Default();
   }
   void interaction_impl::OnChar(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnDeadChar(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnKeyDown(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnKeyUp(UINT, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnLButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnLButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnLButtonUp(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnMButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnMButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnMButtonUp(UINT, const point&)
   {
      Default();
   }
   i32 interaction_impl::OnMouseActivate(::window_sp, UINT, UINT)
   {
      return (i32)Default();
   }
   void interaction_impl::OnMouseMove(UINT, const point&)
   {
      Default();
   }

   bool interaction_impl::OnMouseWheel(UINT, i16, const point&)
   {

      return Default() != FALSE;

   }

   LRESULT interaction_impl::OnRegisteredMouseWheel(WPARAM, LPARAM)
   {
      return Default();
   }
   void interaction_impl::OnRButtonDblClk(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnRButtonDown(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnRButtonUp(UINT, const point&)
   {
      Default();
   }
   void interaction_impl::OnTimer(uptr)
   {
      Default();
   }
   void interaction_impl::OnInitMenu(::user::menu*)
   {
      Default();
   }
   void interaction_impl::OnInitMenuPopup(::user::menu*, UINT, bool)
   {
      Default();
   }
   void interaction_impl::OnAskCbFormatName(__in UINT nMaxCount, __out_ecount_z(nMaxCount) char * lpszName)
   {
      (nMaxCount);
      if (nMaxCount > 0)
      {
         /* defwindow proc should do this for us, but to be safe, we'll do it here too */
         lpszName[0] = '\0';
      }
      Default();
   }
   void interaction_impl::OnChangeCbChain(oswindow, oswindow)
   {
      Default();
   }
   void interaction_impl::OnDestroyClipboard()
   {
      Default();
   }
   void interaction_impl::OnDrawClipboard()
   {
      Default();
   }
   void interaction_impl::OnHScrollClipboard(::window_sp, UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnPaintClipboard(::window_sp, HGLOBAL)
   {
      Default();
   }
   void interaction_impl::OnRenderAllFormats()
   {
      Default();
   }
   void interaction_impl::OnRenderFormat(UINT)
   {
      Default();
   }
   void interaction_impl::OnSizeClipboard(::window_sp, HGLOBAL)
   {
      Default();
   }
   void interaction_impl::OnVScrollClipboard(::window_sp, UINT, UINT)
   {
      Default();
   }
   UINT interaction_impl::OnGetDlgCode()
   {
      return (UINT)Default();
   }
   void interaction_impl::OnMDIActivate(bool, ::window_sp, ::window_sp)
   {
      Default();
   }
   void interaction_impl::OnEnterMenuLoop(bool)
   {
      Default();
   }
   void interaction_impl::OnExitMenuLoop(bool)
   {
      Default();
   }
// Win4 support
   void interaction_impl::OnStyleChanged(i32, LPSTYLESTRUCT)
   {
      Default();
   }
   void interaction_impl::OnStyleChanging(i32, LPSTYLESTRUCT)
   {
      Default();
   }
   void interaction_impl::OnSizing(UINT, RECT *)
   {
      Default();
   }
   void interaction_impl::OnMoving(UINT, RECT *)
   {
      Default();
   }
   void interaction_impl::OnCaptureChanged(::window_sp)
   {
      Default();
   }

   bool interaction_impl::OnDeviceChange(UINT, uptr)
   {

      return Default() != FALSE;

   }

   void interaction_impl::OnWinIniChange(const char *)
   {
      Default();
   }
   void interaction_impl::OnChangeUIState(UINT, UINT)
   {
      Default();
   }
   void interaction_impl::OnUpdateUIState(UINT, UINT)
   {
      Default();
   }
   UINT interaction_impl::OnQueryUIState()
   {
      return (UINT)Default();
   }

// interaction_impl dialog data support
//    void interaction_impl::do_data_exchange(CDataExchange*)
//   { } // default does nothing

// interaction_impl modality support

   void interaction_impl::BeginModalState()
   {

      ::EnableWindow(get_handle(), FALSE);

   }

   void interaction_impl::EndModalState()
   {

      ::EnableWindow(get_handle(), TRUE);

   }

// frame_window
   /*    void frame_window::DelayUpdateFrameTitle()
   { m_nIdleFlags |= idleTitle; }
   void frame_window::DelayRecalcLayout(bool bNotify)
   { m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
   bool frame_window::InModalState() const
   { return m_cModalStack != 0; }
   void frame_window::set_title(const char * pszTitle)

   { m_strTitle = pszTitle; }

   string frame_window::get_title() const
   { return m_strTitle; }
   */



   void interaction_impl::CloseWindow()
   {
      ASSERT(::is_window(get_handle()));
      ::CloseWindow(get_handle());
   }

   bool interaction_impl::OpenIcon()
   {

      ASSERT(::is_window(get_handle()));

      return ::OpenIcon(get_handle()) != FALSE;

   }

////////////////////////////////////////////////////////////////////////////
// UI related interaction_impl functions

   oswindow interaction_impl::get_safe_owner(oswindow hParent, oswindow* pWndTop)
   {
      // get interaction_impl to start with
      oswindow oswindow = hParent;
      if (oswindow == nullptr)
      {
         /* trans      __pointer(::user::frame_window) pFrame = channel::GetRoutingFrame_();
         if (pFrame != nullptr)
         oswindow = pFrame->get_handle();
         else
         oswindow = System.m_puiMain->get_handle();*/
      }

      // a popup interaction_impl cannot be owned by a child interaction_impl
      while (oswindow != nullptr && (::GetWindowLong(oswindow, GWL_STYLE) & WS_CHILD))
         oswindow = ::GetParent(oswindow);

      // determine toplevel interaction_impl to disable as well
      ::oswindow oswindow_Top = oswindow;
      ::oswindow oswindow_Temp = oswindow;
      for (;;)
      {
         if (oswindow_Temp == nullptr)
            break;
         else
            oswindow_Top = oswindow_Temp;
         oswindow_Temp = ::GetParent(oswindow_Top);
      }

      // get last active popup of first non-child that was found
      if (hParent == nullptr && oswindow != nullptr)
         oswindow = ::GetLastActivePopup(oswindow);

      // disable and store top level parent interaction_impl if specified
      if (pWndTop != nullptr)
      {
         if (oswindow_Top != nullptr && ::IsWindowEnabled(oswindow_Top) && oswindow_Top != oswindow)
         {
            *pWndTop = oswindow_Top;
            ::EnableWindow(oswindow_Top, FALSE);
         }
         else
            *pWndTop = nullptr;
      }

      return oswindow;    // return the owner as oswindow
   }


   LRESULT CALLBACK __cbt_filter_hook(i32 code, WPARAM wParam, LPARAM lParam)
   {

      if (code != HCBT_CREATEWND)
      {

         // wait for HCBT_CREATEWND just pass others on...

         return CallNextHookEx(t_hHookOldCbtFilter, code, wParam, lParam);

      }

      ASSERT(lParam != 0);

      ::user::create_struct * pcs = (::user::create_struct *) ((LPCBT_CREATEWND)lParam)->lpcs;


      ASSERT(pcs != nullptr);


      ::windows::interaction_impl * pwnd = t_pwndInit;

      if (pwnd != nullptr || (!(pcs->style & WS_CHILD)))

      {

         t_pwndInit = nullptr;

         // Note: special check to avoid subclassing the IME interaction_impl
         //if (gen_DBCS)
         {
            // check for cheap CS_IME style first...
            if (GetClassLongW((oswindow)wParam, GCL_STYLE) & CS_IME)
               goto lCallNextHook;

            //// get class name of the interaction_impl that is being created
            //const char * pszClassName;
            //char szClassName[_countof("ime") + 1];
            //if(uptr(pcs->lpszClass) > 0xffff)

            //{
            //   pszClassName = pcs->lpszClass;

            //}
            //else
            //{
            //   szClassName[0] = '\0';
            //   GlobalGetAtomName((ATOM)pcs->lpszClass,szClassName,_countof(szClassName));

            //   pszClassName = szClassName;
            //}

            //// a little more expensive to test this way, but necessary...
            //if(::__invariant_stricmp(pszClassName,"ime") == 0)
            //   goto lCallNextHook;

         }

         ASSERT(wParam != 0);

         ::oswindow oswindow = (::oswindow) wParam;

         WNDPROC oldWndProc;

         if (pwnd != nullptr)
         {

            ASSERT(oswindow_get(oswindow) == nullptr);

            pwnd->m_puserinteraction->m_pimpl = pwnd;

            pwnd->attach(oswindow);

            pwnd->pre_subclass_window();

            WNDPROC *pOldWndProc = pwnd->GetSuperWndProcAddr();
            ASSERT(pOldWndProc != nullptr);

            // subclass the interaction_impl with standard __window_procedure
            WNDPROC afxWndProc = __get_window_procedure();
            oldWndProc = (WNDPROC)SetWindowLongPtrW(oswindow, GWLP_WNDPROC,
                                                    (uptr)afxWndProc);
            ASSERT(oldWndProc != nullptr);
            if (oldWndProc != afxWndProc)
               *pOldWndProc = oldWndProc;



         }
      }

lCallNextHook:
      LRESULT lResult = CallNextHookEx(t_hHookOldCbtFilter, code, wParam, lParam);

      return lResult;
   }



   void interaction_impl::_001OnEraseBkgnd(::message::message * pmessage)
   {
      SCAST_PTR(::message::erase_bkgnd, perasebkgnd, pmessage);
      perasebkgnd->m_bRet = true;
      perasebkgnd->set_result(TRUE);
   }



   void interaction_impl::_001OnTriggerMouseInside()
   {

      ::user::interaction_impl::_001OnTriggerMouseInside();

      TRACKMOUSEEVENT tme = { sizeof(tme) };
      tme.dwFlags = TME_LEAVE;
      tme.hwndTrack = get_handle();
      TrackMouseEvent(&tme);

   }



   void interaction_impl::set_context_org(::draw2d::graphics_pointer & pgraphics)
   {

      // graphics will be already set its view port to the interaction_impl for linux - cairo with xlib

      pgraphics->SetViewportOrg(::point());

   }


   /*

   void interaction_impl::_001DeferPaintLayeredWindowBackground(image image)
   {


   }

   */



   bool interaction_impl::get_rect_normal(RECT * prect)

   {

      WINDOWPLACEMENT wp;

      ·zero(wp);

      if (!GetWindowPlacement(&wp))
         return false;

      *prect = wp.rcNormalPosition;


      return true;

   }


   DWORD WINAPI drop_target(LPVOID point)

   {

      interaction_impl* pimpl = (interaction_impl *)point;


      HRESULT hr = OleInitialize(nullptr);

      hr = ::RegisterDragDrop(pimpl->get_handle(), pimpl);

      if (SUCCEEDED(CoCreateInstance(CLSID_DragDropHelper, nullptr,
                                     CLSCTX_INPROC_SERVER,
                                     IID_IDropTargetHelper,
                                     (void**)& pimpl->m_piDropHelper)))
      {
         pimpl->m_bUseDnDHelper = true;
      }

      MSG msg;

      while (mq_get_message(&msg, nullptr, 0, 0xffffffffu))
      {

         TranslateMessage(&msg);

         DispatchMessage(&msg);

      }

      return 0;

   }


   void interaction_impl::register_drop_target()
   {
      m_bUseDnDHelper = false;

      ::CreateThread(nullptr, 0, drop_target, this, 0, nullptr);


   }


   bool interaction_impl::destroy_impl_only()
   {


      return ::user::interaction_impl::destroy_impl_only();

   }


   void interaction_impl::show_task(bool bShow)
   {

      sync_lock sl(m_pmutex);

      // https://www.daniweb.com/programming/software-development/threads/457564/mfc-application-disablehide-taskbar-icon

      if (bShow)
      {

         ModifyStyleEx(WS_EX_TOOLWINDOW, 0, SWP_FRAMECHANGED);

      }
      else
      {

         ModifyStyleEx(0, WS_EX_TOOLWINDOW, SWP_FRAMECHANGED);

      }

      defer_co_initialize_ex(false);

      HRESULT Result = S_OK;

      comptr < ITaskbarList>                     tasklist;

      tasklist.CoCreateInstance(CLSID_TaskbarList, nullptr, CLSCTX_SERVER);

      {

         if (FAILED(tasklist->HrInit()))
         {

            return;

         }

      }

      if (SUCCEEDED(Result))
      {


         if (bShow)
         {

            HRESULT hr = tasklist->AddTab(get_handle());

            informationf("result = %d", hr);

         }
         else
         {

            tasklist->DeleteTab(get_handle());

         }

      }

   }


   /*bool interaction_impl::set_window_pos(class ::user::zorder zorder, i32 x, i32 y, i32 cx, i32 cy, UINT nFlags)
   {

      if (!::user::interaction_impl::set_window_pos(zorder, x, y, cx, cy, nFlags))
      {

         return false;

      }

      if (!(GetExStyle() & WS_EX_LAYERED))
      {


         if (!::set_window_pos(get_handle(), zorder, x, y, cx, cy, nFlags))
         {

            return false;

         }

      }

      return true;

   }
*/

   void interaction_impl::_do_show_window()
   {

      auto edisplay = m_puserinteraction->m_edisplayRequest;

      if (edisplay_command(edisplay) == display_iconic)
      {

         if (no_activate(edisplay))
         {
          
            ::ShowWindow(m_oswindow, SW_SHOWMINNOACTIVE);

         }
         else
         {

            ::ShowWindow(m_oswindow, SW_MINIMIZE);

         }

      }
      else if (is_visible(edisplay))
      {

         if (GetExStyle() & WS_EX_LAYERED)
         {

            ::ShowWindow(m_oswindow, SW_NORMAL);

         }
         else
         {

            auto iShow = windows_show_window(edisplay);

            ::ShowWindow(m_oswindow, iShow);

         }
      
      }
      else
      {

         ::ShowWindow(m_oswindow, SW_HIDE);

      }

      m_puserinteraction->m_edisplay = edisplay;

   }




} // namespace windows


#undef __window_procedure


#define VARIAS_MENSAGENS_DO_WINDOWS_RECEBIDAS_PELA_FUNCAO_QUE_RECEBE_AS_MENSAGENS_A_FUNCAO_QUE_RECEBE_AS_MENSAGENS_RETORNA_1_SE_A_MENSAGEM_SE_PROCESSOU_OU_QUER_DIZER_QUE_PROCESSOU_SERA_QUE_ATINGIU_O_LIMITE 1
// isso é um comentario e zero (0) se não processou
LRESULT CALLBACK __window_procedure(oswindow oswindow, const ::id & id, WPARAM wparam, LPARAM lparam)

{
   //::output_debug_string("\n__window_procedure message = " + ::str::from(message));

   if (message == WM_GETTEXT)
   {

     // ::output_debug_string("\n__window_procedure message = WM_GETTEXT");

   }
   else if(message == WM_GETTEXTLENGTH)
   {

      //::output_debug_string("\n__window_procedure message = WM_GETTEXTLENGTH");

   }

   if (WM_USER + 7654 == message)
   {

      ::DestroyWindow((HWND) lparam);


      ::SetEvent((HANDLE)wparam);

      return 0;

   }




   if (::get_context_system() == nullptr)
   {

      return 0;

   }

   if (System.acmesystem() == nullptr)
   {

      return 0;

   }

   ::user::interaction_impl * pimpl = System.acmesystem()->impl_from_handle(oswindow);

   pimpl->m_uiMessage = message;

   pimpl->m_wparam = wparam;

   pimpl->m_lparam = lparam;

   ::user::interaction * puserinteraction = pimpl->m_puserinteraction;

   if (message == e_message_mouse_move)
   {

      if (lparam == pimpl->m_lparamLastMouseMove)
      {

         return 0;

      }

      pimpl->m_lparamLastMouseMove = lparam;

   }

   LRESULT lresult;

#if 0

   if (message == e_message_show_window)
   {

      output_debug_string("e_message_show_window");

   }
   else if (message == e_message_window_position_changing)
   {

      output_debug_string("e_message_window_position_changing");

   }
   else if (message == e_message_window_position_changed)
   {

      output_debug_string("e_message_window_position_changed");

   }
   else if (message == e_message_left_button_down)
   {

      output_debug_string("e_message_left_button_down()");

   }
   else if (message == e_message_destroy)
   {

      output_debug_string("e_message_destroy");

   }
   else if (message == e_message_nccreate)
   {

      output_debug_string("e_message_nccreate()");

   }

#endif


   if (pimpl->m_bDestroyImplOnly || ::is_null(puserinteraction))
   {

      lresult = pimpl->call_message_handler(message, wparam, lparam);


   }
   else if (::is_set(puserinteraction))
   {

      if (message == WM_GETTEXT)
      {

         auto length = puserinteraction->_009GetWindowText((char *)lparam, (int)(wparam));
        
         if (length >= 0)
         {

            return length;

         }

         return puserinteraction->Default();

      }
      else if (message == WM_GETTEXTLENGTH)
      {

         auto length = puserinteraction->_009GetWindowTextLength();

         if (length >= 0)
         {

            return length;

         }

         return puserinteraction->Default();

      }
      else if (puserinteraction->m_bMoving || puserinteraction->m_bMoveWindow)
      {

         if (message == e_message_window_position_changing)
         {

            return ::DefWindowProc(oswindow, message, wparam, lparam);


         }
         else if (message == e_message_window_position_changed)
         {

            return ::DefWindowProc(oswindow, message, wparam, lparam);


         }

      }

      lresult = puserinteraction->call_message_handler(message, wparam, lparam);

   }
   else
   {

      lresult = ::DefWindowProc(oswindow, message, wparam, lparam);


   }

   return lresult;

}


WNDPROC CLASS_DECL_AURA __get_window_procedure()
{

   return &::__window_procedure;

}


CLASS_DECL_AURA bool hook_window_create(::windows::interaction_impl * pwindow)
{

   if (pwindow == nullptr)
   {

      return false;

   }

   if (pwindow->get_handle() != nullptr)
   {

      return false;

   }

   if (t_hHookOldCbtFilter == nullptr)
   {

      t_hHookOldCbtFilter = ::SetWindowsHookExW(WH_CBT, windows::__cbt_filter_hook, nullptr, ::GetCurrentThreadId());

      if (t_hHookOldCbtFilter == nullptr)
      {

         return false;

      }

   }

   if (t_hHookOldCbtFilter == nullptr)
   {

      return false;

   }

   t_pwndInit = pwindow;

   if (t_pwndInit == nullptr)   // hook not already in progress
   {

      return false;

   }

   if (t_pwndInit != pwindow)
   {

      return false;

   }

   return true;

}


CLASS_DECL_AURA bool unhook_window_create()
{

   if (t_pwndInit != nullptr)
   {

      t_pwndInit = nullptr;

      return false;   // was not successfully hooked

   }

   return true;

}


void CLASS_DECL_AURA _handle_activate(::window_sp pwindow, WPARAM nState, ::window_sp pWndOther)
{

   ASSERT(pwindow);

   // send WM_ACTIVATETOPLEVEL when top-level parents change
   if (!((pwindow)->GetStyle() & WS_CHILD))
   {
      __pointer(::user::interaction) pTopLevel = (pwindow)->GetTopLevel();
      if (pTopLevel && (!pWndOther || !::is_window((pWndOther)->get_handle()) || pTopLevel != (pWndOther)->GetTopLevel()))
      {
         // lParam points to interaction_impl getting the e_message_activate message and
         //  oswindow_Other from the e_message_activate.
         oswindow oswindow_2[2];
         oswindow_2[0] = (pwindow)->get_handle();
         if (!pWndOther)
         {
            oswindow_2[1] = nullptr;
         }
         else
         {

            oswindow_2[1] = (pWndOther)->get_handle();

         }

         // send it...
         pTopLevel->send_message(WM_ACTIVATETOPLEVEL, nState, (LPARAM)&oswindow_2[0]);

      }

   }

}


void __term_windowing()
{

   if (t_hHookOldCbtFilter != nullptr)
   {

      ::UnhookWindowsHookEx(t_hHookOldCbtFilter);

      t_hHookOldCbtFilter = nullptr;

   }

}


::user::interaction_impl * oswindow_get(oswindow oswindow)
{

   if (oswindow == nullptr)
   {

      return nullptr;

   }

   auto psystem = ::get_context_system();

   if (psystem == nullptr)
   {

      return nullptr;

   }

   sync_lock slSystem(psystem->m_pmutex);

   auto pmap = psystem->m_pwindowmap;

   if (!pmap)
   {

      return nullptr;

   }

   sync_lock slMap(pmap->m_pmutex);

   ::user::primitive * pbase;

   if (!pmap->m_map.lookup(oswindow, pbase))
   {

      return nullptr;

   }

   return dynamic_cast <::user::interaction_impl *>(pbase);

}



